# SPDX-FileCopyrightText: Â© 2017 Jeremiah Orians
#
# SPDX-License-Identifier: GPL-3.0-or-later

DEFINE add_eax, 83C0
DEFINE add_ebx, 83C3
DEFINE add_ecx, 83C1
DEFINE add_edx, 83C2
DEFINE add_esi, 83C6
DEFINE add_eax,ebx 01D8
DEFINE add_eax,ecx 01C8
DEFINE add_ebx,eax 01C3
DEFINE add_ecx,edi 01F9
DEFINE and_eax,ebx 21D8
DEFINE and_eax, 25
DEFINE call_eax FFD0
DEFINE call E8
DEFINE cmp_eax, 83F8
DEFINE cmp_ebp, 83FD
DEFINE cmp_ebx, 83FB
DEFINE cmp_ecx, 83F9
DEFINE cmp_edx, 83FA
DEFINE cmp_esi, 83FE
DEFINE cmp_eax,ebx 39D8
DEFINE cmp_eax,ecx 39C8
DEFINE cmp_ebx,ecx 39CB
DEFINE cmp_ebx,edx 39D3
DEFINE cmp_esi,edi 39FE
DEFINE idiv_ebx F7FB
DEFINE imul_eax, 6BC0
DEFINE imul_ebp, 6BED
DEFINE imul_eax,ebx 0FAFC3
DEFINE int CD
DEFINE jbe8 76
DEFINE je 0F84
DEFINE jg 0F8F
DEFINE jl 0F8C
DEFINE jle 0F8E
DEFINE jmp E9
DEFINE jne 0F85
DEFINE lea_ecx,[esp] 8D0C24
DEFINE mov_eax, B8
DEFINE mov_ebx, BB
DEFINE mov_ecx, B9
DEFINE mov_edi, BF
DEFINE mov_edx, BA
DEFINE mov_esi, BE
DEFINE mov_eax,ebp 89E8
DEFINE mov_eax,ebx 89D8
DEFINE mov_eax,ecx 89C8
DEFINE mov_eax,edx 89D0
DEFINE mov_eax,esi 89F0
DEFINE mov_ebp,eax 89C5
DEFINE mov_ebp,edx 89D5
DEFINE mov_ebx,eax 89C3
DEFINE mov_ebx,ecx 89CB
DEFINE mov_ebx,edx 89D3
DEFINE mov_ecx,eax 89C1
DEFINE mov_ecx,ebx 89D9
DEFINE mov_edi,esi 89F7
DEFINE mov_edx,eax 89C2
DEFINE mov_edx,ebx 89DA
DEFINE mov_esi,eax 89C6
DEFINE mov_esi,edi 89FE
DEFINE mov_eax,[DWORD] A1
DEFINE mov_ebx,[DWORD] 8B1D
DEFINE mov_ecx,[DWORD] 8B0D
DEFINE mov_al,[eax] 8A00
DEFINE mov_al,[ebx] 8A03
DEFINE mov_al,[ecx] 8A01
DEFINE mov_al,[edx] 8A02
DEFINE mov_bl,[ebx] 8A1B
DEFINE mov_bl,[ecx] 8A19
DEFINE mov_bl,[edx] 8A1A
DEFINE mov_cl,[ebx] 8A0B
DEFINE mov_cl,[ebx+BYTE] 8A4B
DEFINE mov_eax,[eax] 8B00
DEFINE mov_eax,[ebx] 8B03
DEFINE mov_eax,[eax+BYTE] 8B40
DEFINE mov_eax,[ebp+BYTE] 8B45
DEFINE mov_eax,[ebx+BYTE] 8B43
DEFINE mov_eax,[ecx+BYTE] 8B41
DEFINE mov_eax,[edx+BYTE] 8B42
DEFINE mov_ebp,[ebp] 8B6D00
DEFINE mov_ebx,[eax+BYTE] 8B58
DEFINE mov_ebx,[ebx] 8B1B
DEFINE mov_ebx,[ebx+BYTE] 8B5B
DEFINE mov_ebx,[ecx+BYTE] 8B59
DEFINE mov_ecx,[eax+BYTE] 8B48
DEFINE mov_ecx,[ebx] 8B0B
DEFINE mov_ecx,[ecx] 8B09
DEFINE mov_ecx,[ecx+BYTE] 8B49
DEFINE mov_ecx,[edx+BYTE] 8B4A
DEFINE mov_edi,[edx+BYTE] 8B7A
DEFINE mov_edx,[edx+BYTE] 8B52
DEFINE mov_[DWORD],eax A3
DEFINE mov_[DWORD],ebx 891D
DEFINE mov_[DWORD],ecx 890D
DEFINE mov_[DWORD],edx 8915
DEFINE mov_[ebx],al 8803
DEFINE mov_[ecx],al 8801
DEFINE mov_[esi],al 8806
DEFINE mov_[ecx],bl 8819
DEFINE mov_[eax],ebx 8918
DEFINE mov_[eax],ecx 8908
DEFINE mov_[eax+BYTE],ebx 8958
DEFINE mov_[eax+BYTE],ecx 8948
DEFINE mov_[eax+BYTE],edx 8950
DEFINE mov_[ebp+BYTE],eax 8945
DEFINE mov_[ebp+BYTE],edx 8955
DEFINE mov_[ebp+BYTE],esi 8975
DEFINE mov_[ebx],eax 8903
DEFINE mov_[ecx+BYTE],eax 8941
DEFINE mov_[edx],eax 8902
DEFINE mov_[edx+BYTE],eax 8942
DEFINE mov_[edx+BYTE],ebp 896A
DEFINE mov_[edx+BYTE],ebx 895A
DEFINE mov_[edx+BYTE],ecx 894A
DEFINE mov_[edx+BYTE],esi 8972
DEFINE movzx_eax,al 0FB6C0
DEFINE movzx_ebx,bl 0FB6DB
DEFINE movzx_ecx,cl 0FB6C9
DEFINE NULL 00000000
DEFINE pop_eax 58
DEFINE pop_ebp 5D
DEFINE pop_ebx 5B
DEFINE pop_ecx 59
DEFINE pop_edi 5F
DEFINE pop_edx 5A
DEFINE pop_esi 5E
DEFINE push_eax 50
DEFINE push_ebp 55
DEFINE push_ebx 53
DEFINE push_ecx 51
DEFINE push_edi 57
DEFINE push_edx 52
DEFINE push_esi 56
DEFINE ret C3
DEFINE sal_eax, C1E0
DEFINE shr_eax, C1E8
DEFINE shr_ebx, C1EB
DEFINE sub_eax, 83E8
DEFINE sub_ecx, 83E9
DEFINE sub_esi, 83EE
DEFINE xchg_eax,ebx 93


	# Register usage:
	# EAX => Temps

	# Struct TYPE format: (size 28)
	# NEXT => 0
	# SIZE => 4
	# OFFSET => 8
	# INDIRECT => 12
	# MEMBERS => 16
	# TYPE => 20
	# NAME => 24

	# Struct TOKEN_LIST format: (size 20)
	# NEXT => 0
	# LOCALS/PREV => 4
	# S => 8
	# TYPE => 12
	# ARGS/DEPTH => 16

# Where the ELF Header is going to hit
# Simply jump to _start
# Our main function
:_start
	pop_eax                                     # Get the number of arguments
	pop_ebx                                     # Get the program name
	pop_ebx                                     # Get the actual input name
	mov_ecx, %0                                 # prepare read_only
	mov_eax, %5                                 # the syscall number for open()
	int !0x80                                   # Now open that damn file
	mov_[DWORD],eax &Input_file                 # Preserve the file pointer we were given

	pop_ebx                                     # Get the actual output name
	mov_ecx, %577                               # Prepare file as O_WRONLY|O_CREAT|O_TRUNC
	mov_edx, %384                               # Prepare file as RW for owner only (600 in octal)
	mov_eax, %5                                 # the syscall number for open()
	int !0x80                                   # Now open that damn file
	cmp_eax, !0                                 # Check for missing output
	jg %_start_out                              # Have real input
	mov_eax, %1                                 # Use stdout

:_start_out
	mov_[DWORD],eax &Output_file                # Preserve the file pointer we were given

	mov_eax, %45                                # the Syscall # for SYS_BRK
	mov_ebx, %0                                 # Get current brk
	int !0x80                                   # Let the kernel do the work
	mov_[DWORD],eax &MALLOC                     # Set our malloc pointer
	mov_eax, %0                                 # HEAD = NULL
	call %read_all_tokens                       # Read all tokens
	call %Reverse_List                          # Reverse order
#	call %debug_list                            # Try to figure out what is wrong
	mov_[DWORD],eax &global_token               # Set global_token
	call %program                               # Convert into program
	mov_eax, &header_string1                    # Our header string
	call %File_Print                            # Print it
	mov_eax,[DWORD] &output_list                # Our output_list
	call %recursive_output                      # Print core program
#	mov_eax, &header_string2                    # Our Enable debug
#	call %File_Print                            # Print it
	mov_eax, &header_string3                    # Our second label
	call %File_Print                            # Print it
	mov_eax,[DWORD] &globals_list               # Our globals
	call %recursive_output                      # Get them
	mov_eax, &header_string4                    # Our final header
	call %File_Print                            # Print it
	mov_eax,[DWORD] &strings_list               # Our strings
	call %recursive_output                      # Get them
	mov_eax, &header_string5                    # Make this a bare assembly
	call %File_Print                            # Print it

:Done
	# program completed Successfully
	mov_ebx, %0                                 # All is well
	mov_eax, %1                                 # put the exit syscall number in eax
	int !0x80                                   # Call it a good day

:header_string1  "
# Core program
"
:header_string2  "
:ELF_data
"
:header_string3  "
# Program global variables
"
:header_string4  "
# Program strings
"
:header_string5  "
:ELF_end
"


# read_all_tokens function
# Receives Token_List* in EAX
# Tokenizes all input and returns updated list in EAX
# Returns TOKEN in EAX
# Uses EAX for C
:read_all_tokens
	mov_[DWORD],eax &Token
	call %fgetc
:read_all_tokens_loop
	cmp_eax, !-4                                # Check for EOF
	je %read_all_tokens_done                    # Stop if found
	call %get_token                             # Read all tokens
	jmp %read_all_tokens_loop                   # Loop
:read_all_tokens_done
	mov_eax,[DWORD] &Token
	ret


# get_token function
# Receives INT in EAX
# Makes a list of TOKEN_LIST
# C and STRING_INDEX are stored in memory, ECX is used for S and EDX is used for current
# Returns C in EAX
:get_token
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX

	mov_[DWORD],eax &C                          # Set C

	mov_eax, %20                                # Malloc CURRENT
	call %malloc                                # Get Pointer
	mov_edx,eax                                 # Set CURRENT

	mov_eax, %256                               # Malloc the string
	call %malloc                                # Get pointer to S
	mov_ecx,eax                                 # Set S
	mov_[edx+BYTE],ecx !8                       # CURRENT->S = S
:reset
	mov_[DWORD],ecx &string_index               # S[0]
	mov_eax,[DWORD] &C                          # Using C

	call %clear_white_space                     # Clear WhiteSpace
	mov_[DWORD],eax &C                          # Set C

	cmp_eax, !-4                                # Check for EOF
	je %get_token_abort                         # if EOF abort

	cmp_eax, !35                                # Check for '#'
	jne %get_token_alpha                        # Nope

	# Deal with # line comments
	call %purge_macro                           # Let it handle it
	mov_[DWORD],eax &C                          # Set C
	jmp %reset                                  # Try again

:get_token_alpha
	mov_eax,[DWORD] &C                          # Send C
	mov_ebx, &alphas                            # Get alphanumerics
	call %In_Set                                # See if in set
	cmp_eax, !1                                 # IF TRUE
	jne %get_token_symbol                       # Otherwise

	# Store keywords
	mov_eax,[DWORD] &C                          # Send C
	call %preserve_keyword                      # Store
	mov_[DWORD],eax &C                          # Set C
	jmp %get_token_done                         # Be done with this token

:get_token_symbol
	mov_eax,[DWORD] &C                          # Send C
	mov_ebx, &symbols                           # Get symbols
	call %In_Set                                # See if in set
	cmp_eax, !1                                 # IF TRUE
	jne %get_token_strings                      # Otherwise

	# Store symbols
	mov_eax,[DWORD] &C                          # Send C
	call %preserve_symbol                       # Store
	mov_[DWORD],eax &C                          # Set C
	jmp %get_token_done                         # Be done with this token

:get_token_strings
	mov_eax,[DWORD] &C                          # Send C
	mov_ebx, &strings                           # Get strings
	call %In_Set                                # See if in set
	cmp_eax, !1                                 # IF TRUE
	jne %get_token_comment                      # Otherwise

	# Store String
	mov_eax,[DWORD] &C                          # Send C
	call %consume_word                          # Store
	mov_[DWORD],eax &C                          # Set C
	jmp %get_token_done                         # Be done with this token

:get_token_comment
	mov_eax,[DWORD] &C                          # Send C
	cmp_eax, !47                                # IF '/' == C
	jne %get_token_else                         # Otherwise

	call %consume_byte                          # Hope it just is '/'
	mov_[DWORD],eax &C                          # Set C

	cmp_eax, !42                                # IF '*' we have '/*'
	jne %get_token_comment_line                 # Check for '//'

	# Deal with /* block comments */
	call %fgetc                                 # get next C
	mov_[DWORD],eax &C                          # Set C
:get_token_comment_block_outer
	mov_eax,[DWORD] &C                          # Using C
	cmp_eax, !47                                # IF '/' != C
	je %get_token_comment_block_done            # be done

:get_token_comment_block_inner
	mov_eax,[DWORD] &C                          # Using C
	cmp_eax, !42                                # IF '*' != C
	je %get_token_comment_block_iter            # jump over

	# Deal with inner loop
	call %fgetc                                 # get next C
	mov_[DWORD],eax &C                          # Set C
	jmp %get_token_comment_block_inner          # keep going

:get_token_comment_block_iter
	call %fgetc                                 # get next C
	mov_[DWORD],eax &C                          # Set C
	jmp %get_token_comment_block_outer

:get_token_comment_block_done
	call %fgetc                                 # get next C
	mov_[DWORD],eax &C                          # Set C
	jmp %reset                                  # throw away, try again

:get_token_comment_line
	cmp_eax, !47                                # IF '/' we have //
	jne %get_token_done                         # keep if just '/'

	# Deal with // line comment
	call %fgetc                                 # drop to match
	mov_[DWORD],eax &C                          # Set C
	jmp %reset                                  # throw away, try again

:get_token_else
	mov_eax,[DWORD] &C                          # Send C
	call %consume_byte
	mov_[DWORD],eax &C                          # Set C

:get_token_done
	mov_eax,[DWORD] &Token                      # TOKEN
	mov_[edx+BYTE],eax !4                       # CURRENT->PREV = TOKEN
	mov_[edx],eax                               # CURRENT->NEXT = TOKEN
	mov_[DWORD],edx &Token                      # TOKEN = CURRENT

:get_token_abort
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	mov_eax,[DWORD] &C                          # Return C
	ret


# Malloc isn't actually required if the program being built fits in the initial memory
# However, it doesn't take much to add it.
# Requires [MALLOC] to be initialized and EAX to have the number of desired bytes
:malloc
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_ebx,[DWORD] &MALLOC                     # Using the current pointer
	add_ebx,eax                                 # Request the number of desired bytes
	mov_eax, %45                                # the Syscall # for SYS_BRK
	int !0x80                                   # call the Kernel
	mov_eax,[DWORD] &MALLOC                     # Return pointer
	mov_[DWORD],ebx &MALLOC                     # Update pointer
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# clear_white_space function
# Receives INT C in EAX
# Returns first non-whitespace char in EAX
:clear_white_space
	cmp_eax, !32                                # Check for ' '
	je %clear_white_space_wipe                  # wipe it out

	cmp_eax, !10                                # Check for '\n'
	je %clear_white_space_wipe                  # wipe it output

	cmp_eax, !9                                 # Check for '\t'
	jne %clear_white_space_done                 # looks like non-whitespace

:clear_white_space_wipe
	call %fgetc                                 # Read a new byte
	cmp_eax, !-4                                # Check for EOF
	je %clear_white_space_done                  # Short circuit
	jmp %clear_white_space                      # iterate

:clear_white_space_done
	ret


# In_Set function
# Receives Char C in EAX and CHAR* in EBX
# Returns 1 if true, zero if false in EAX
:In_Set
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
:In_Set_loop
	mov_cl,[ebx]                                # Read char
	movzx_ecx,cl                                # Zero extend it

	cmp_eax,ecx                                 # See if they match
	je %In_Set_True                             # return true

	cmp_ecx, !0                                 # Check for NULL
	je %In_Set_False                            # return false

	add_ebx, !1                                 # s = s + 1
	jmp %In_Set_loop                            # Keep looping

:In_Set_True
	mov_eax, %1                                 # Set True
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:In_Set_False
	mov_eax, %0                                 # Set FALSE
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:alphas  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
:symbols  "<=>|&!-"
:strings  '22 27 00'


# purge_macro function
# Receives CH in EAX
# Reads chars until Line feed is read
# returns line feed
:purge_macro
	call %fgetc                                 # read next char
	cmp_eax, !10                                # Check for '\n'
	jne %purge_macro                            # Keep going
	ret


# preserve_keyword function
# Receives INT C in EAX
# collects all chars in keyword
# Returns C in EAX
# Uses ECX for INT C
:preserve_keyword
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # Setup C
	mov_ebx, &alphas                            # Concerning ourselves with "abc.."
:preserve_keyword_loop
	call %In_Set                                # Check if alphanumerics
	cmp_eax, !1                                 # IF TRUE
	jne %preserve_keyword_label                 # Otherwise check for label

	mov_eax,ecx                                 # Pass C
	call %consume_byte                          # consume that byte
	mov_ecx,eax                                 # Update C
	jmp %preserve_keyword_loop                  # keep looping

:preserve_keyword_label
	mov_eax,ecx                                 # Fix return
	cmp_eax, !58                                # Check for ':'
	jne %preserve_keyword_done                  # be done

	# Fix our goto label
	call %fixup_label                           # Fix the label
	mov_eax, %32                                # Return Whitespace

:preserve_keyword_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# preserve_symbol function
# Receives INT C in EAX
# collects all chars in symbol
# Returns C in EAX
# Uses ECX for INT C
:preserve_symbol
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # Setup C
	mov_ebx, &symbols                           # Concerning ourselves with "<=>.."
:preserve_symbol_loop
	call %In_Set                                # Check if symbol
	cmp_eax, !1                                 # IF TRUE
	jne %preserve_symbol_done                   # Otherwise be done

	mov_eax,ecx                                 # Pass C
	call %consume_byte                          # consume that byte
	mov_ecx,eax                                 # Update C
	jmp %preserve_symbol_loop                   # keep looping

:preserve_symbol_done
	mov_eax,ecx                                 # Fix return
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# consume_word function
# receives INT C in EAX
# returns INT C in EAX
# Uses EAX for C, EBX for FREQ and ECX for ESCAPE
:consume_word
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ebx,eax                                 # FREQ = C
	mov_ecx, %0                                 # ESCAPE = FALSE
:consume_word_loop
	cmp_ecx, !0                                 # IF !ESCAPE
	jne %consume_word_escape                    # Enable escape

	cmp_eax, !92                                # if '\\'
	jne %consume_word_iter                      # keep state

	mov_ecx, %1                                 # ESCAPE = TRUE
	jmp %consume_word_iter                      # keep going

:consume_word_escape
	mov_ecx, %0                                 # ESCAPE = FALSE

:consume_word_iter
	call %consume_byte                          # read next char

	cmp_ecx, !0                                 # IF ESCAPE
	jne %consume_word_loop                      # keep looping

	cmp_eax,ebx                                 # IF C != FREQ
	jne %consume_word_loop                      # keep going

	call %fgetc                                 # return next char
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# consume_byte function
# Receives INT C in EAX
# Inserts C into string S, updates String S
# Returns Next char in EAX
:consume_byte
	push_ebx                                    # Protect EBX
	mov_ebx,[DWORD] &string_index               # S[0]
	mov_[ebx],al                                # S[0] = C
	add_ebx, !1                                 # S = S + 1
	mov_[DWORD],ebx &string_index               # Update S
	call %fgetc
	pop_ebx                                     # Restore EBX
	ret


# fixup_label function
# Receives S in ECX
# prepends ':' to string and returns registers unchanged
# Uses EAX for HOLD, EBX for PREV and ECX for S[0]
:fixup_label
	push_eax                                    # Protect EAX
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax, %58                                # HOLD = ':'
	mov_ecx,[edx+BYTE] !8                       # HOLD_STRING[0]
:fixup_label_loop
	mov_ebx,eax                                 # PREV = HOLD
	mov_al,[ecx]                                # HOLD = HOLD_STRING[I]
	movzx_eax,al                                # make useful
	mov_[ecx],bl                                # HOLD_STRING[I] = PREV
	add_ecx, !1                                 # I = I + 1
	cmp_eax, !0                                 # IF NULL == HOLD
	jne %fixup_label_loop                       # Keep looping

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	pop_eax                                     # Restore EAX
	ret


# fgetc function
# Loads FILE* from [INPUT_FILE]
# Returns -4 (EOF) or char in EAX
:fgetc
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_eax, %-4                                # Put EOF in eax
	push_eax                                    # Assume bad (If nothing read, value will remain EOF)
	lea_ecx,[esp]                               # Get stack address
	mov_ebx,[DWORD] &Input_file                 # Where are we reading from
	mov_eax, %3                                 # the syscall number for read
	mov_edx, %1                                 # set the size of chars we want
	int !0x80                                   # call the Kernel
	pop_eax                                     # Get either char or EOF
	cmp_eax, !-4                                # Check for EOF
	je %fgetc_done                              # Return as is
	movzx_eax,al                                # Make it useful
:fgetc_done
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# Reverse_List function
# Receives List in EAX
# Returns the list reversed in EAX
:Reverse_List
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ebx,eax                                 # Set HEAD
	mov_eax, %0                                 # ROOT = NULL
:Reverse_List_Loop
	cmp_ebx, !0                                 # WHILE HEAD != NULL
	je %Reverse_List_Done                       # Stop otherwise

	mov_ecx,[ebx]                               # NEXT = HEAD->NEXT
	mov_[ebx],eax                               # HEAD->NEXT = ROOT
	mov_eax,ebx                                 # ROOT = HEAD
	mov_ebx,ecx                                 # HEAD = NEXT
	jmp %Reverse_List_Loop                      # Keep Going

:Reverse_List_Done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# recursive_output function
# Receives list in EAX
# walks the list and prints the I->S for all nodes backwards
# Uses EBX for I
:recursive_output
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	cmp_eax, !0                                 # Check for NULL
	je %recursive_output_done                   # Skip the work
	mov_ebx,eax                                 # I = Head

	mov_eax,[ebx]                               # Iterate to next Token
	call %recursive_output                      # Recurse

	mov_eax,[ebx+BYTE] !8                       # Using S
	call %File_Print                            # Print it

:recursive_output_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# File_Print function
# Receives CHAR* in EAX
# calls fputc for every non-null char
:File_Print
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ebx,eax                                 # Protect S
	cmp_eax, !0                                 # Protect against nulls
	je %File_Print_Done                         # Simply don't try to print them
:File_Print_Loop
	mov_al,[ebx]                                # Read byte
	movzx_eax,al                                # zero extend
	cmp_eax, !0                                 # Check for NULL
	je %File_Print_Done                         # Stop at NULL

	call %fputc                                 # write it
	add_ebx, !1                                 # S = S + 1
	jmp %File_Print_Loop                        # Keep going

:File_Print_Done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# fputc function
# receives CHAR in EAX and load FILE* from [OUTPUT_FILE]
# writes char and returns
:fputc
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_eax                                    # We are writing eax
	lea_ecx,[esp]                               # Get stack address
	mov_ebx,[DWORD] &Output_file                # Write to target file
	mov_eax, %4                                 # the syscall number for write
	mov_edx, %1                                 # set the size of chars we want
	int !0x80                                   # call the Kernel
	pop_eax                                     # Restore stack
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


:enum_error_open_curly
"ERROR in enum
Expected {
"
:enum_error_equal
"ERROR in enum
Expected =
"
:enum_error_close_curly
"ERROR in enum
Expected }
"
:enum_error_semi_colon
"ERROR in enum
Expected ;
"

# program function
# receives nothing, returns nothing
# Uses EAX for type_size
:program
	# The binary initialized the globals to null, so we can skip those steps
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX

:new_type
	mov_eax,[DWORD] &global_token         # Using global_token
	cmp_eax, !0                           # Check if NULL
	je %program_done                      # Be done if null

	mov_ebx,[eax+BYTE] !8                 # GLOBAL_TOKEN->S
	mov_eax, &enum                        # "enum"
	call %match                           # IF GLOBAL_TOKEN->S == "enum"
	cmp_eax, !0                           # If true
	jne %program_else                     # Looks like not an enum

	# Deal with minimal anonymous enums
	mov_eax,[DWORD] &global_token         # Using global_token
	mov_eax,[eax]                         # global_token->next
	mov_[DWORD],eax &global_token         # global_token = global_token->next

	mov_eax, &enum_error_open_curly       # Using "ERROR in enum\nExpected {\n"
	mov_ebx, &open_curly_brace            # Using "{"
	call %require_match                   # Require match and skip

:enumerator
	mov_eax,[DWORD] &global_token         # Using global token
	mov_eax,[eax+BYTE] !8                 # global_token->S
	mov_ebx, %0                           # NULL
	mov_ecx,[DWORD] &global_constant_list # global_constant_list
	call %sym_declare                     # Declare the constant
	mov_[DWORD],eax &global_constant_list # global_constant_list = sym_declare(global_token->s, NULL, global_constant_list);

	mov_eax,[DWORD] &global_token         # Using global_token
	mov_eax,[eax]                         # global_token->next
	mov_[DWORD],eax &global_token         # global_token = global_token->next

	mov_eax, &enum_error_equal            # Using "ERROR in enum\nExpected =\n"
	mov_ebx, &equal                       # Using "="
	call %require_match                   # Require match and skip

	mov_ebx,[DWORD] &global_token         # Using global_token
	mov_eax,[DWORD] &global_constant_list # Use global_constant_list
	mov_[eax+BYTE],ebx !16                # global_constant_list->arguments = global_token->next

	mov_eax,[DWORD] &global_token         # Using global_token
	mov_eax,[eax]                         # global_token->next
	mov_[DWORD],eax &global_token         # global_token = global_token->next

	mov_ebx,[DWORD] &global_token         # Use global_token
	mov_ebx,[eax+BYTE] !8                 # global_token->s
	mov_eax, &comma                       # ","
	call %match                           # IF global_token->s == ","
	cmp_eax, !0                           # If true
	jne %enum_end                         # No comma means no more enumerators

	# Skip comma
	mov_eax,[DWORD] &global_token         # Using global_token
	mov_eax,[eax]                         # global_token->next
	mov_[DWORD],eax &global_token         # global_token = global_token->next

	# Check if there are more enumerators or if it was a trailing comma
	mov_ebx,[eax+BYTE] !8                 # global_token->s
	mov_eax, &close_curly_brace           # "}"
	call %match                           # IF global_token->s == "}"
	cmp_eax, !0                           # If true
	jne %enumerator                       # More enumerators

:enum_end
	mov_eax, &enum_error_close_curly      # Using "ERROR in enum\nExpected }\n"
	mov_ebx, &close_curly_brace           # Using "}"
	call %require_match                   # Require match and skip

	mov_eax, &enum_error_semi_colon       # Using "ERROR in enum\nExpected ;\n"
	mov_ebx, &semicolon                   # Using ";"
	call %require_match                   # Require match and skip

	jmp %new_type                         # go around again

:program_else
	call %type_name                             # Figure out the type_size
	cmp_eax, !0                                 # IF NULL == type_size
	je %new_type                                # it was a new type

	# Add to global symbol table
	mov_ebx,eax                                 # put type_size in the right spot
	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_ecx,[DWORD] &global_symbol_list         # Using global_symbol_list
	call %sym_declare                           # Declare symbol
	mov_[DWORD],eax &global_symbol_list         # global_symbol_list = sym_declare(global_token->s, type_size, global_symbol_list);
	mov_ebx,[DWORD] &global_token               # Using global token
	mov_ebx,[ebx]                               # global_token->next
	mov_[DWORD],ebx &global_token               # global_token = global_token->next

	mov_ebx,[DWORD] &global_token               # Using global token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &semicolon                         # ";"
	call %match                                 # if(match(";", global_token->s))
	cmp_eax, !0                                 # If true
	jne %program_function                       # looks like not a match

	# Deal with the global variable
	mov_ebx,[DWORD] &globals_list               # Using globals_list
	mov_eax, &program_string_0                  # ":GLOBAL_"
	call %emit                                  # Emit it
	mov_ebx,eax                                 # update globals_list

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !4                       # global token->prev
	mov_eax,[eax+BYTE] !8                       # global token->prev->s
	call %emit                                  # Emit it

	mov_ebx,eax                                 # update globals_list
	mov_eax, &program_string_1                  # "\nNULL\n"
	call %emit                                  # Emit it
	mov_[DWORD],eax &globals_list               # update globals_list

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next
	jmp %new_type                               # go around again

:program_function
	mov_ebx,[DWORD] &global_token               # Using global token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &open_paren                        # "("
	call %match                                 # if(match(";", global_token->s))
	cmp_eax, !0                                 # If true
	jne %program_error                          # Otherwise deal with error case

	# Deal with function definition
	call %declare_function                      # Lets get the parsing rolling
	jmp %new_type                               # Keep looping through functions

:program_error
	# Deal with the case of something we don't support
	# NOT IMPLEMENTED

:program_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

# Strings needed by the program function
:program_string_0  ":GLOBAL_"
:program_string_1  "
NULL
"


# declare_function function
# Receives nothing and returns nothing
# Sets current function and adds it to the global function list
:declare_function
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax, %0                                 # Using NULL
	mov_[DWORD],eax &current_count              # current_count = 0

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !4                       # global token->prev
	mov_eax,[eax+BYTE] !8                       # global token->prev->s
	mov_ebx, %0                                 # NULL
	mov_ecx,[DWORD] &global_function_list       # global_function_list
	call %sym_declare                           # sym_declare(global_token->prev->s, NULL, global_function_list);
	mov_[DWORD],eax &function                   # function = sym_declare(global_token->prev->s, NULL, global_function_list);
	mov_[DWORD],eax &global_function_list       # global_function_list = function

	call %collect_arguments                     # collect all of the function arguments

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !8                       # global token->s
	mov_ebx, &semicolon                         # ";"
	call %match                                 # IF global token->s == ";"
	cmp_eax, !0                                 # If true
	jne %declare_function_full                  # It was a prototype

	# Deal with prototypes
	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax]                               # global token->next
	mov_[DWORD],eax &global_token               # global token = global token->next
	jmp %declare_function_done                  # Move on

:declare_function_full
	# Deal with full function definitions
	mov_eax, &declare_function_string_0         # "# Defining function "
	call %emit_out                              # emit it

	mov_eax,[DWORD] &function                   # function
	mov_eax,[eax+BYTE] !8                       # function->s
	call %emit_out                              # emit it

	mov_eax, &declare_function_string_1         # "\n:FUNCTION_"
	call %emit_out                              # emit it

	mov_eax,[DWORD] &function                   # function
	mov_eax,[eax+BYTE] !8                       # function->s
	call %emit_out                              # emit it

	mov_eax, &declare_function_string_3         # "\n"
	call %emit_out                              # emit it

	call %statement                             # Recursively get the function pieces

	mov_eax,[DWORD] &output_list                # output
	mov_eax,[eax+BYTE] !8                       # output->s
	mov_ebx, &declare_function_string_2         # "ret\n"
	call %match                                 # IF output->s == "ret\n"
	cmp_eax, !0                                 # If true we can skip adding it
	je %declare_function_done                   # otherwise we need to add it

	# Add the return to the end of a function lacking a return;
	mov_eax, &declare_function_string_2         # "ret\n"
	call %emit_out                              # emit it

:declare_function_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:declare_function_string_0  "# Defining function "
:declare_function_string_1  "
:FUNCTION_"
:declare_function_string_2  "ret
"
:declare_function_string_3  "
"


# collect_arguments function
# Receives nothing
# Returns Nothing
# Adds arguments to the function definition
# holds struct type* type_size in ECX, then replace with struct token_list* a in ECX when type_size is used
:collect_arguments
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next
:collect_arguments_loop
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &close_paren                       # ")"
	call %match                                 # IF global_token->S == ")"
	cmp_eax, !0                                 # we reached the end
	je %collect_arguments_done                  # be done

	# deal with the case of there are arguments
	call %type_name                             # Get the type
	mov_ecx,eax                                 # put type_size safely out of the way

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &close_paren                       # ")"
	call %match                                 # IF global_token->S == ")"
	cmp_eax, !0                                 # is a foo(int, char,void) case
	je %collect_arguments_common                # deal with commas

	# Trying second else
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &comma                             # ","
	call %match                                 # IF global_token->S == ","
	cmp_eax, !0                                 # then deal with the common
	je %collect_arguments_common                # case of commas between arguments

	# deal with foo(int a, char b)
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_ebx,ecx                                 # put type_size in the right place
	mov_ecx,[DWORD] &function                   # Using function
	mov_ecx,[ecx+BYTE] !16                      # function->args
	call %sym_declare                           # sym_declare(global_token->s, type_size, function->arguments);
	mov_ecx,eax                                 # put a in a safe place

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !16                      # function->args
	cmp_eax, !0                                 # IF function->args == NULL
	jne %collect_arguments_another              # otherwise it isn't the first

	# Deal with the case of first argument in the function
	mov_eax, %-4                                # -4
	mov_[ecx+BYTE],eax !16                      # a->depth = -4
	jmp %collect_arguments_next                 # get to next

:collect_arguments_another
	# deal with the case of non-first arguments
	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !16                      # function->args
	mov_eax,[eax+BYTE] !16                      # function->args->depth
	sub_eax, !4                                 # function->args->depth - 4
	mov_[ecx+BYTE],eax !16                      # a->depth = function->args->depth - 4

:collect_arguments_next
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_eax,[DWORD] &function                   # Using function
	mov_[eax+BYTE],ecx !16                      # function->args = a

:collect_arguments_common
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &comma                             # ","
	call %match                                 # IF global_token->S == ","
	cmp_eax, !0                                 # then deal with the comma
	jne %collect_arguments_loop                 # otherwise loop

	# keep foo(bar(), 1) expressions working
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next
	jmp %collect_arguments_loop                 # keep going

:collect_arguments_done
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# statement function
# Receives nothing
# Returns nothing
# Walks down global_token recursively to collect the contents of the function
:statement
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &open_curly_brace                  # "{"
	call %match                                 # IF global_token->S == "{"
	jne %statement_label                        # otherwise try label

	# deal with { statement }
	call %recursive_statement                   # Statements inside of statements for days
	jmp %statement_done                         # Be done

:statement_label
	mov_al,[ebx]                                # global_token->S[0]
	movzx_eax,al                                # make it useful
	cmp_eax, !58                                # IF global_token->S == ':'
	jne %statement_local                        # otherwise try locals

	# deal with labels
	mov_eax,ebx                                 # put global_token->S in the right spot
	call %emit_out                              # emit it

	mov_eax, &statement_string_0                # Using "\t#C goto label\n"
	call %emit_out                              # emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next
	jmp %statement_done                         # be done

:statement_local
	mov_eax,ebx                                 # put global_token->S in the right place
	mov_ebx, &prim_types                        # pointer to primitive types
	call %lookup_type                           # See if found
	cmp_eax, !0                                 # IF NULL == lookup_type(global_token->S, prim_types)
	jne %statement_local_success                # Sweet a new local

	# Second chance
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &struct                            # "struct"
	call %match                                 # IF global_token->S == "struct"
	cmp_eax, !0                                 # then we are a local
	jne %statement_if                           # otherwise try IF

:statement_local_success
	call %collect_local                         # Grab those locals
	jmp %statement_done                         # be done

:statement_if
	mov_eax, &if_string                         # Using "if"
	call %match                                 # IF global_token->S == "if"
	cmp_eax, !0                                 # then we have an if statement
	jne %statement_do                           # otherwise try DO

	# Deal with IF statement
	call %process_if                            # DO IT
	jmp %statement_done                         # be done

:statement_do
	mov_eax, &do_string                         # Using "do"
	call %match                                 # IF global_token->S == "do"
	cmp_eax, !0                                 # then we have a do statement
	jne %statement_while                        # otherwise try WHILE

	# Deal with DO statement
	call %process_do                            # DO IT
	jmp %statement_done                         # be done

:statement_while
	mov_eax, &while_string                      # Using "while"
	call %match                                 # IF global_token->S == "while"
	cmp_eax, !0                                 # then we have a while statement
	jne %statement_for                          # otherwise try FOR

	# Deal with WHILE statement
	call %process_while                         # DO IT
	jmp %statement_done                         # be done

:statement_for
	mov_eax, &for_string                        # Using "for"
	call %match                                 # IF global_token->S == "for"
	cmp_eax, !0                                 # then we have a for statement
	jne %statement_asm                          # otherwise try ASM

	# Deal with FOR statement
	call %process_for                           # DO IT
	jmp %statement_done                         # be done

:statement_asm
	mov_eax, &asm_string                        # Using "asm"
	call %match                                 # IF global_token->S == "asm"
	cmp_eax, !0                                 # then we have an asm statement
	jne %statement_goto                         # otherwise try GOTO

	# Deal with ASM statement
	call %process_asm                           # Hit it
	jmp %statement_done                         # be done

:statement_goto
	mov_eax, &goto_string                       # Using "goto"
	call %match                                 # IF global_token->S == "goto"
	cmp_eax, !0                                 # then we have a goto statement
	jne %statement_return                       # Otherwise try RETURN

	# Deal with GOTO statement
	mov_eax, &statement_string_1                # Using "jmp %"
	call %emit_out                              # emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %emit_out                              # emit it

	mov_eax, &statement_string_2                # Using "\n"
	call %emit_out                              # emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_eax, &statement_string_4                # Using "ERROR in statement\nMissing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure it has the required
	jmp %statement_done                         # Be done

:statement_return
	mov_eax, &return_string                     # Using "return"
	call %match                                 # IF global_token->S == "return"
	cmp_eax, !0                                 # then we have a return statement
	jne %statement_break                        # Otherwise try BREAK

	# Deal with RETURN Statement
	call %return_result                         # Return anything they want
	jmp %statement_done                         # be done

:statement_break
	mov_eax, &break_string                      # Using "break"
	call %match                                 # IF global_token->S == "break"
	cmp_eax, !0                                 # then we have a break statement
	jne %statement_continue                     # Otherwise try CONTINUE

	# Deal with BREAK statement
	call %process_break                         # Lets do some damage
	jmp %statement_done                         # be done

:statement_continue
	mov_eax, &continue_string                   # Using "continue"
	call %match                                 # IF global_token->S == "continue"
	cmp_eax, !0                                 # then we have a continue statement
	jne %statement_else                         # Otherwise we are punting to an expression

	# Deal with CONTINUE statement
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_eax, &statement_string_3                # Using "\n#continue statement\n"
	call %emit_out                              # emit it

	mov_eax, &statement_string_4                # Using "ERROR in statement\nMissing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Don't forget the ";"
	jmp %statement_done                         # Be done

:statement_else
	call %expression                            # Collect expression
	mov_eax, &statement_string_4                # Using "ERROR in statement\nMissing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # make sure we have it

:statement_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:statement_string_0  "	#C goto label
"
:statement_string_1  "jmp %"
:statement_string_2  "
"
:statement_string_3  "
#continue statement
"
:statement_string_4  "ERROR in statement
Missing ;
"


# recursive_statement function
# Receives nothing
# Returns nothing
# Walks the global_token list to build the contents of statements
# Uses struct token_list* frame in ECX
:recursive_statement
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_ecx,[DWORD] &function                   # Using function
	mov_ecx,[ecx+BYTE] !4                       # frame = function->locals

:recursive_statement_loop
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &close_curly_brace                 # Using "}"
	call %match                                 # IF global_token->S == "}"
	cmp_eax, !0                                 # Then we are done recursing
	je %recursive_statement_cleanup             # and then we clean up

	# Deal with the recursive calls
	call %statement                             # Deal with another statement
	jmp %recursive_statement_loop               # loop some more

:recursive_statement_cleanup
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_eax, &recursive_statement_string_0      # Using "ret\n"
	mov_ebx,[DWORD] &output_list                # Using output
	mov_ebx,[ebx+BYTE] !8                       # output->S
	call %match                                 # IF output->S == "ret\n"
	cmp_eax, !0                                 # Then we can skip the clean up
	je %recursive_statement_done                # and be done

	# Deal with cleanup
	mov_ebx,[DWORD] &function                   # Using function
	mov_ebx,[ebx+BYTE] !4                       # i = function->locals
	mov_eax, &recursive_statement_string_1      # Using "pop_ebx\t# _recursive_statement_locals\n"

:recursive_statement_locals
	cmp_ebx,ecx                                 # IF frame != i
	je %recursive_statement_done                # Otherwise be done

	# Lets emit
	call %emit_out                              # emit it
	mov_ebx,[ebx]                               # i = i->next
	jmp %recursive_statement_locals             # keep going

:recursive_statement_done
	mov_eax,[DWORD] &function                   # Using function
	mov_[eax+BYTE],ecx !4                       # function->locals = frame
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:recursive_statement_string_0  "ret
"
:recursive_statement_string_1  "pop_ebx	# _recursive_statement_locals
"


# return_result function
# Receives nothing
# Returns nothing
# Cleans up function and generates return
# Also handles returning expressions
:return_result
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next

	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # make it useful
	cmp_eax, !59                                # If global_token->S[0] == ';'
	je %return_result_cleanup                   # Go straight to cleanup

	call %expression                            # get the expression we are returning

:return_result_cleanup
	mov_eax, &return_result_string_0            # Using "ERROR in return_result\nMISSING ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	mov_ebx,[DWORD] &function                   # Using function
	mov_ebx,[ebx+BYTE] !4                       # function->locals
	mov_eax, &return_result_string_1            # Using "pop_ebx\t# _return_result_locals\n"
:return_result_locals
	cmp_ebx, !0                                 # IF NULL == i
	je %return_result_done                      # Be done

	call %emit_out                              # Emit out pop
	mov_ebx,[ebx]                               # i = i->NEXT
	jmp %return_result_locals                   # Keep going

:return_result_done
	mov_eax, &return_result_string_2            # Using "ret\n"
	call %emit_out                              # Emit it
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:return_result_string_0  "ERROR in return_result
MISSING ;
"
:return_result_string_1  "pop_ebx	# _return_result_locals
"
:return_result_string_2  "ret
"


# collect_local function
# Receives nothing
# Returns nothing
# Walks global_token list to create function locals
# Uses ECX for struct token_list* A
:collect_local
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	call %type_name                             # Get the local's type

	mov_ebx,eax                                 # Put struct type* type_size in the right place
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_ecx,[DWORD] &function                   # Using function
	mov_ecx,[ecx+BYTE] !4                       # function->locals
	call %sym_declare                           # Declare it
	mov_ecx,eax                                 # put it away safely

	# Try for main
	mov_eax, &main_string                       # Using "main"
	mov_ebx,[DWORD] &function                   # Using function
	mov_ebx,[ebx+BYTE] !8                       # function->S
	call %match                                 # IF match("main", function->s)
	cmp_eax, !0                                 # possible
	jne %collect_local_fresh                    # try to see if fresh function

	# Ok we are in main, now to see if main is fresh
	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !4                       # function->locals
	cmp_eax, !0                                 # IF NULL == function->locals
	jne %collect_local_fresh                    # try to see if fresh function

	# Sweet we are in a fresh main
	mov_eax, %-20                               # We start at -20
	mov_[ecx+BYTE],eax !16                      # a->DEPTH = -20
	jmp %collect_local_common                   # Go to the commons

:collect_local_fresh
	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !16                      # function->args
	cmp_eax, !0                                 # IF NULL == function->args
	jne %collect_local_first                    # Otherwise see if first

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !4                       # function->locals
	cmp_eax, !0                                 # IF NULL == function->locals
	jne %collect_local_first                    # Otherwise try first

	# Sweet we are in a fresh function
	mov_eax, %-8                                # We start at -8
	mov_[ecx+BYTE],eax !16                      # a->DEPTH = -8
	jmp %collect_local_common                   # Go to the commons

:collect_local_first
	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !4                       # function->locals
	cmp_eax, !0                                 # IF NULL == function->locals
	jne %collect_local_else                     # Looks like we are just another local

	# Ok we are the first local
	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !16                      # function->args
	mov_eax,[eax+BYTE] !16                      # function->args->depth
	sub_eax, !8                                 # function->arguments->depth - 8
	mov_[ecx+BYTE],eax !16                      # a->DEPTH = function->arguments->depth - 8
	jmp %collect_local_common                   # Go to the commons

:collect_local_else
	# Always the last to know
	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !4                       # function->locals
	mov_eax,[eax+BYTE] !16                      # function->locals->depth
	sub_eax, !4                                 # function->locals->depth - 4
	mov_[ecx+BYTE],eax !16                      # a->DEPTH = function->locals->depth - 4

:collect_local_common
	mov_eax,[DWORD] &function                   # Using function

	mov_[eax+BYTE],ecx !4                       # function->locals = a
	mov_ecx,[ecx+BYTE] !8                       # a->S

	mov_eax, &collect_local_string_0            # Using "# Defining local "
	call %emit_out                              # emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %emit_out                              # emit it

	mov_eax, &collect_local_string_1            # Using "\n"
	call %emit_out                              # emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_ebx,[eax+BYTE] !8                       # global_token->S
	mov_eax, &equal                             # Using "="
	call %match                                 # IF match("=", global_token->s)
	cmp_eax, !0                                 # Deal with assignment
	jne %collect_local_done                     # Otherwise finish it

	# Deal with assignment
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	call %expression                            # Recurse

:collect_local_done
	mov_eax, &collect_local_string_2            # Using "ERROR in collect_local\nMissing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	mov_eax, &collect_local_string_3            # Using "push_eax\t#"
	call %emit_out                              # emit it

	mov_eax,ecx                                 # put A->S where it belongs
	call %emit_out                              # emit it

	mov_eax, &collect_local_string_1            # Using "\n"
	call %emit_out                              # emit it

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:collect_local_string_0  "# Defining local "
:collect_local_string_1  "
"
:collect_local_string_2  "ERROR in collect_local
Missing ;
"
:collect_local_string_3  "push_eax	#"


# process_asm function
# Receives nothing
# Returns nothing
# Simply inlines the asm statements
# Uses EBX for global_token temp storage
:process_asm
	push_ebx                                    # Protect EBX
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &process_asm_string_0              # Using "ERROR in process_asm\nMISSING (\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make sure we have it

	mov_ebx,[DWORD] &global_token               # Using global_token
:process_asm_iter
	mov_eax,[ebx+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !34                                # IF global_token->S[0] == '\"'
	jne %process_asm_done                       # Otherwise be done

	mov_eax,[ebx+BYTE] !8                       # global_token->S
	add_eax, !1                                 # global_token->S + 1
	call %emit_out                              # Emit it

	mov_eax, &process_asm_string_1              # Using "\n"
	call %emit_out                              # Emit it

	mov_ebx,[ebx]                               # global_token->NEXT
	mov_[DWORD],ebx &global_token               # global_token = global_token->NEXT
	jmp %process_asm_iter                       # keep going

:process_asm_done
	mov_eax, &process_asm_string_2              # Using "ERROR in process_asm\nMISSING )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	mov_eax, &process_asm_string_3              # Using "ERROR in process_asm\nMISSING ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	pop_ebx                                     # Restore EBX
	ret

:process_asm_string_0  "ERROR in process_asm
MISSING (
"
:process_asm_string_1  "
"
:process_asm_string_2  "ERROR in process_asm
MISSING )
"
:process_asm_string_3  "ERROR in process_asm
MISSING ;
"


# process_if function
# Receives nothing
# Returns Nothing
# Increments current_count recurses into expression + statement
# Uses ECX for char* NUMBER_STRING
:process_if
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &current_count              # Using current count
	mov_ebx,eax                                 # Preparing for update
	add_ebx, !1                                 # current_count + 1
	mov_[DWORD],ebx &current_count              # current_count = current_count + 1
	call %numerate_number                       # convert to string
	mov_ecx,eax                                 # put NUMBER_STRING in place

	mov_eax, &process_if_string_0               # Using "# IF_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &process_if_string_1               # Using "ERROR in process_if\nMISSING (\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make sure we have it

	call %expression                            # Recurse to get the IF(...) part

	mov_eax, &process_if_string_2               # Using "test_eax,eax\nje %ELSE_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_if_string_3               # Using "ERROR in process_if\nMISSING )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	call %statement                             # Recursive to get the IF(){...} part

	mov_eax, &process_if_string_4               # Using "jmp %_END_IF_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_if_string_5               # Using ":ELSE_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &else_string                       # Using "else"
	call %match                                 # IF global_token->S == "else"
	cmp_eax, !0                                 # Then we need to collect the else too
	jne %process_if_done                        # Otherwise finish up

	# deal with else statement
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	call %statement                             # Recurse to get the ELSE {...} part

:process_if_done
	mov_eax, &process_if_string_6               # Using ":_END_IF_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:process_if_string_0  "# IF_"
:process_if_string_1  "ERROR in process_if
MISSING (
"
:process_if_string_2  "test_eax,eax
je %ELSE_"
:process_if_string_3  "ERROR in process_if
MISSING )
"
:process_if_string_4  "jmp %_END_IF_"
:process_if_string_5  ":ELSE_"
:process_if_string_6  ":_END_IF_"


# save_break_frame microfunction
# Overwrites EAX and EBX
# Saves break frame on stack
# Returns to caller
:save_break_frame
	pop_ebx                                     # Save return Address
	mov_eax,[DWORD] &break_frame                # Get break_frame
	push_eax                                    # Store as nested_locals
	mov_eax,[DWORD] &break_target_head          # Get break_target_head
	push_eax                                    # Store as nested_break_head
	mov_eax,[DWORD] &break_target_func          # Get break_target_func
	push_eax                                    # Store as nested_break_func
	mov_eax,[DWORD] &break_target_num           # Get break_target_num
	push_eax                                    # Store as nested_break_num
	push_ebx                                    # Put return back in place
	ret                                         # Return to caller


# restore_break_frame microfunction
# Overwrites EAX and EBX
# Restores break frame from stack
# Returns to caller
:restore_break_frame
	pop_ebx                                     # Save return Address
	pop_eax                                     # Get nested_break_num
	mov_[DWORD],eax &break_target_num           # Restore break_target_num
	pop_eax                                     # Get nested_break_func
	mov_[DWORD],eax &break_target_func          # Restore break_target_func
	pop_eax                                     # Get nested_break_head
	mov_[DWORD],eax &break_target_head          # Restore break_target_head
	pop_eax                                     # Get nested_locals
	mov_[DWORD],eax &break_frame                # Restore break_frame
	push_ebx                                    # Put return back in place
	ret                                         # Return to caller


# set_break_frame microfunction
# Receives char* head in EAX and char* num in EBX
# Overwrites EAX and EBX
# Returns to calling function
:set_break_frame
	mov_[DWORD],eax &break_target_head          # update break_target_head
	mov_[DWORD],ebx &break_target_num           # update break_target_num
	mov_ebx,[DWORD] &function                   # Using function
	mov_eax,[ebx+BYTE] !4                       # function->LOCALS
	mov_[DWORD],eax &break_frame                # break_frame = function->LOCALS
	mov_eax,[ebx+BYTE] !8                       # function->S
	mov_[DWORD],eax &break_target_func          # break_target_func = function->S
	ret                                         # Return to sender


# process_do function
# Receives Nothing
# Returns Nothing
# Increments current_count and leverages save/restore_break_frame pieces
# Uses ECX for char* NUMBER_STRING
:process_do
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	call %save_break_frame                      # Save the frame

	mov_eax,[DWORD] &current_count              # Using current count
	mov_ebx,eax                                 # Preparing for update
	add_ebx, !1                                 # current_count + 1
	mov_[DWORD],ebx &current_count              # current_count = current_count + 1
	call %numerate_number                       # convert to string
	mov_ecx,eax                                 # put NUMBER_STRING in place

	mov_eax, &process_do_string_0               # Using "DO_END_"
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %set_break_frame                       # Set the frame

	mov_eax, &process_do_string_1               # Using ":DO_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	call %statement                             # Do the DO {...} part

	mov_eax, &process_do_string_2               # Using "ERROR in process_do\nMISSING while\n"
	mov_ebx, &while_string                      # Using "while"
	call %require_match                         # Make sure we have it

	mov_eax, &process_do_string_3               # Using "ERROR in process_do\nMISSING (\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make sure we have it

	call %expression                            # Do the WHILE (...) part

	mov_eax, &process_do_string_4               # Using "ERROR in process_do\nMISSING )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	mov_eax, &process_do_string_5               # Using "ERROR in process_do\nMISSING ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	mov_eax, &process_do_string_6               # Using "test_eax,eax\njne %DO_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_do_string_7               # Using ":DO_END_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	call %restore_break_frame                   # Restore the old break frame

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:process_do_string_0  "DO_END_"
:process_do_string_1  ":DO_"
:process_do_string_2  "ERROR in process_do
MISSING while
"
:process_do_string_3  "ERROR in process_do
MISSING (
"
:process_do_string_4  "ERROR in process_do
MISSING )
"
:process_do_string_5  "ERROR in process_do
MISSING ;
"
:process_do_string_6  "test_eax,eax
jne %DO_"
:process_do_string_7  ":DO_END_"


# process_while function
# Receives nothing
# Returns nothing
# Increments current_count and leverages save/restore_break_frame pieces
# Uses ECX for char* NUMBER_STRING
:process_while
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	call %save_break_frame                      # Save break_frame

	mov_eax,[DWORD] &current_count              # Using current count
	mov_ebx,eax                                 # Preparing for update
	add_ebx, !1                                 # current_count + 1
	mov_[DWORD],ebx &current_count              # current_count = current_count + 1
	call %numerate_number                       # convert to string
	mov_ecx,eax                                 # put NUMBER_STRING in place

	mov_eax, &process_while_string_0            # Using "END_WHILE_"
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %set_break_frame                       # Set it and forget it

	mov_eax, &process_while_string_1            # Using ":WHILE_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &process_while_string_2            # Using "ERROR in process_while\nMISSING (\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make sure we have it

	call %expression                            # Deal with the WHILE (...) part

	mov_eax, &process_while_string_3            # Using "test_eax,eax\nje %END_WHILE_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_while_string_4            # Using "# THEN_while_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_while_string_5            # Using "ERROR in process_while\nMISSING )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	call %statement                             # Deal with the {....} part

	mov_eax, &process_while_string_6            # Using "jmp %WHILE_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_while_string_7            # Using ":END_WHILE_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	call %restore_break_frame                   # Restore the old break frame

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:process_while_string_0  "END_WHILE_"
:process_while_string_1  ":WHILE_"
:process_while_string_2  "ERROR in process_while
MISSING (
"
:process_while_string_3  "test_eax,eax
je %END_WHILE_"
:process_while_string_4  "# THEN_while_"
:process_while_string_5  "ERROR in process_while
MISSING )
"
:process_while_string_6  "jmp %WHILE_"
:process_while_string_7  ":END_WHILE_"


# process_for function
# Receives Nothing
# Returns Nothing
# Increments current_count and leverages save/restore_break_frame pieces
# Uses ECX for char* NUMBER_STRING
:process_for
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	call %save_break_frame                      # Save the frame

	mov_eax,[DWORD] &current_count              # Using current count
	mov_ebx,eax                                 # Preparing for update
	add_ebx, !1                                 # current_count + 1
	mov_[DWORD],ebx &current_count              # current_count = current_count + 1
	call %numerate_number                       # convert to string
	mov_ecx,eax                                 # put NUMBER_STRING in place

	mov_eax, &process_for_string_0              # Using "FOR_END_"
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %set_break_frame                       # Set it and forget it

	mov_eax, &process_for_string_1              # Using "# FOR_initialization_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &process_for_string_2              # Using "ERROR in process_for\nMISSING (\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make Sure we have it

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &semicolon                         # Using ";"
	call %match                                 # IF global_token->S == ";"
	cmp_eax, !0                                 # Then no initializer
	je %process_for_terminator                  # And skip getting the expression

	# Deal with FOR (...; case
	call %expression                            # Get the FOR ( ... ; part

:process_for_terminator
	mov_eax, &process_for_string_3              # Using ":FOR_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_4              # Using "ERROR in process_for\nMISSING ;1\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	call %expression                            # Get the FOR ( ; ... ; Part

	mov_eax, &process_for_string_5              # Using "test_eax,eax\nje %FOR_END_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_6              # Using "jmp %FOR_THEN_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_7              # Using ":FOR_ITER_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_8              # Using "ERROR in process_for\nMISSING ;2\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	call %expression                            # Get the FOR (;;...) part

	mov_eax, &process_for_string_9              # Using "jmp %FOR_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_10             # Using ":FOR_THEN_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_11             # Using "ERROR in process_for\nMISSING )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	call %statement                             # Get FOR (;;) {...} part

	mov_eax, &process_for_string_12             # Using "jmp %FOR_ITER_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Passing NUMBER_STRING
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	mov_eax, &process_for_string_13             # Using ":FOR_END_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID_out                          # uniqueID_out(function->s, number_string)

	call %restore_break_frame                   # Restore the old break frame

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:process_for_string_0  "FOR_END_"
:process_for_string_1  "# FOR_initialization_"
:process_for_string_2  "ERROR in process_for
MISSING (
"
:process_for_string_3  ":FOR_"
:process_for_string_4  "ERROR in process_for
MISSING ;1
"
:process_for_string_5  "test_eax,eax
je %FOR_END_"
:process_for_string_6  "jmp %FOR_THEN_"
:process_for_string_7  ":FOR_ITER_"
:process_for_string_8  "ERROR in process_for
MISSING ;2
"
:process_for_string_9  "jmp %FOR_"
:process_for_string_10 ":FOR_THEN_"
:process_for_string_11 "ERROR in process_for
MISSING )
"
:process_for_string_12 "jmp %FOR_ITER_"
:process_for_string_13 ":FOR_END_"


# process_break function
# Receives nothing
# Returns nothing
# Handles the break out of loops case
# Uses EBX for struct token_list* break_frame and ECX for struct token_list* I
:process_break
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &break_target_head          # Catch big error
	cmp_eax, !0                                 # IF(NULL == break_target_head)
	je %process_break_bad                       # I'm sorry Mr White but you have stage-3 lung cancer

	mov_eax,[DWORD] &function                   # Using function
	mov_ecx,[eax+BYTE] !4                       # I = function->LOCALS
	mov_ebx,[DWORD] &break_frame                # Put break_frame in the right spot
	mov_eax, &process_break_string_1            # Using "pop_ebx\t# break_cleanup_locals\n"

:process_break_iter
	cmp_ecx, !0                                 # IF (NULL == I)
	je %process_break_cleaned                   # We are done

	cmp_ebx,ecx                                 # IF I != break_frame
	je %process_break_cleaned                   # We are done

	call %emit_out                              # Emit it
	mov_ecx,[ecx]                               # I = I->NEXT
	jmp %process_break_iter                     # Keep looping

:process_break_cleaned
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &process_break_string_2            # Using "jmp %"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &break_target_head          # Get what we are in
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &break_target_func          # Get what function we are in
	call %emit_out                              # Emit it

	mov_eax, &underline                         # Using "_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &break_target_num           # Get dem digits
	call %emit_out                              # Emit it

	mov_eax, &process_break_string_3            # Using "\n"
	call %emit_out                              # Emit it

	mov_eax, &process_break_string_4            # Using "ERROR in break statement\nMissing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:process_break_bad
	# Breaking badly
	mov_eax, %2                                 # Using standard error
	mov_[DWORD],eax &Output_file                # write to standard error
#	call %line_error                            # Write useful debug info
	mov_eax,ecx                                 # put S in the right place
	call %File_Print                            # print it

	mov_eax, &process_break_string_0            # Ending string
	call %File_Print                            # print it
	jmp %Exit_Failure                           # Abort Hard

:process_break_string_0  "Not inside of a loop or case statement"
:process_break_string_1  "pop_ebx	# break_cleanup_locals
"
:process_break_string_2  "jmp %"
:process_break_string_3  "
"
:process_break_string_4  "ERROR in break statement
Missing ;
"


# expression function
# Receives Nothing
# Returns Nothing
# Walks global_token and updates output_list
# Uses EAX and EBX for match and ECX for char* store
:expression
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	call %bitwise_expr                          # Collect bitwise expressions

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &equal                             # "="
	call %match                                 # IF global_token->S == "="
	cmp_eax, !0                                 # We have to deal with assignment
	jne %expression_done                        # Looks like nope

	# Deal with possible assignment
	mov_ecx, &expression_string_1               # Assume "mov_[ebx],al\n" by default
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !4                       # global_token->PREV
	mov_ebx,[ebx+BYTE] !8                       # global_token->PREV->S
	mov_eax, &close_bracket                     # Using "]"
	call %match                                 # IF global_token->S == "]"
	cmp_eax, !0                                 # Then we might have a char
	jne %expression_int                         # Otherwise INT

	mov_ebx,[DWORD] &current_target             # Using current_target
	mov_ebx,[ebx+BYTE] !24                      # current_target->NAME
	mov_eax, &type_char_indirect_name           # Using "char*"
	call %match                                 # Intentional inefficiency because I feel like it
	cmp_eax, !0                                 # IF current_target->NAME == "char*"
	jne %expression_int                         # Do char anyway

	jmp %expression_common                      # Looks like we have to use "mov_[ebx],al\n"

:expression_int
	mov_ecx, &expression_string_0               # Use "mov_[ebx],eax\n"

:expression_common
	mov_eax, &expression                        # Passing expression
	call %common_recursion                      # Recurse
	mov_eax,ecx                                 # Using Store
	call %emit_out                              # Emit it
	mov_eax, %0                                 # Using NULL
	mov_[DWORD],eax &current_target             # current_target = NULL

:expression_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:expression_string_0  "mov_[ebx],eax
"
:expression_string_1  "mov_[ebx],al
"


# bitwise_expr function
# Receives nothing
# Returns nothing
# Walks global_token list and updates output list
# Just calls other functions
:bitwise_expr
	call %relational_expr                       # Walk up the tree
	call %bitwise_expr_stub                     # Let general recursion do the work
	ret


# bitwise_expr_stub function
# Receives nothing
# Returns Nothing
# Just calls general_recursion a bunch
# Uses EAX, EBX, ECX and EDX for passing constants to general recursion
:bitwise_expr_stub
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX

	mov_eax, &relational_expr                   # Using relational_expr
	mov_ebx, &bitwise_expr_stub_string_0        # Using "and_eax,ebx\n"
	mov_ecx, &bitwise_and                       # Using "&"
	mov_edx, &bitwise_expr_stub                 # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &relational_expr                   # Using relational_expr
	mov_ebx, &bitwise_expr_stub_string_0        # Using "and_eax,ebx\n"
	mov_ecx, &logical_and                       # Using "&&"
	mov_edx, &bitwise_expr_stub                 # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &relational_expr                   # Using relational_expr
	mov_ebx, &bitwise_expr_stub_string_1        # Using "or_eax,ebx\n"
	mov_ecx, &bitwise_or                        # Using "|"
	mov_edx, &bitwise_expr_stub                 # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &relational_expr                   # Using relational_expr
	mov_ebx, &bitwise_expr_stub_string_1        # Using "or_eax,ebx\n"
	mov_ecx, &logical_or                        # Using "||"
	mov_edx, &bitwise_expr_stub                 # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &relational_expr                   # Using relational_expr
	mov_ebx, &bitwise_expr_stub_string_2        # Using "xor_eax,ebx\n"
	mov_ecx, &bitwise_xor                       # Using "^"
	mov_edx, &bitwise_expr_stub                 # And recurse
	call %general_recursion                     # Hit it

	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:bitwise_expr_stub_string_0  "and_eax,ebx
"
:bitwise_expr_stub_string_1  "or_eax,ebx
"
:bitwise_expr_stub_string_2  "xor_eax,ebx
"


# relational_expr function
# Receives nothing
# Returns Nothing
# Walks global_token list and updates output list
# just calls other function
:relational_expr
	call %additive_expr                         # Walk up the tree
	call %relational_expr_stub                  # Recurse
	ret


# relational_expr_stub function
# Receives nothing
# Returns Nothing
# Just calls general_recursion a bunch
# Uses EAX, EBX, ECX and EDX for passing constants to general recursion
:relational_expr_stub
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX

	mov_eax, &additive_expr                     # Using additive_expr
	mov_ebx, &relational_expr_stub_string_0     # Using "cmp\nsetl_al\nmovzx_eax,al\n"
	mov_ecx, &less_than_string                  # Using "<"
	mov_edx, &relational_expr_stub              # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &additive_expr                     # Using additive_expr
	mov_ebx, &relational_expr_stub_string_1     # Using "cmp\nsetle_al\nmovzx_eax,al\n"
	mov_ecx, &less_than_equal_string            # Using "<="
	mov_edx, &relational_expr_stub              # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &additive_expr                     # Using additive_expr
	mov_ebx, &relational_expr_stub_string_2     # Using "cmp\nsetge_al\nmovzx_eax,al\n"
	mov_ecx, &greater_than_equal_string         # Using ">="
	mov_edx, &relational_expr_stub              # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &additive_expr                     # Using additive_expr
	mov_ebx, &relational_expr_stub_string_3     # Using "cmp\nsetg_al\nmovzx_eax,al\n"
	mov_ecx, &greater_than_string               # Using ">"
	mov_edx, &relational_expr_stub              # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &additive_expr                     # Using additive_expr
	mov_ebx, &relational_expr_stub_string_4     # Using "cmp\nsete_al\nmovzx_eax,al\n"
	mov_ecx, &equal_to_string                   # Using "=="
	mov_edx, &relational_expr_stub              # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &additive_expr                     # Using additive_expr
	mov_ebx, &relational_expr_stub_string_5     # Using "cmp\nsetne_al\nmovzx_eax,al\n"
	mov_ecx, &not_equal_string                  # Using "!="
	mov_edx, &relational_expr_stub              # And recurse
	call %general_recursion                     # Hit it

	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:relational_expr_stub_string_0  "cmp
setl_al
movzx_eax,al
"
:relational_expr_stub_string_1  "cmp
setle_al
movzx_eax,al
"
:relational_expr_stub_string_2  "cmp
setge_al
movzx_eax,al
"
:relational_expr_stub_string_3  "cmp
setg_al
movzx_eax,al
"
:relational_expr_stub_string_4  "cmp
sete_al
movzx_eax,al
"
:relational_expr_stub_string_5  "cmp
setne_al
movzx_eax,al
"


# additive_expr function
# Receives nothing
# Returns Nothing
# Walks global_token list and updates output list
# just calls other function
:additive_expr
	call %postfix_expr                          # Walk up the tree
	call %additive_expr_stub                    # Recurse
	ret


# additive_expr_stub function
# Receives nothing
# Returns Nothing
# Just calls general_recursion a bunch
# Uses EAX, EBX, ECX and EDX for passing constants to general recursion
:additive_expr_stub
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_0       # Using "add_eax,ebx\n"
	mov_ecx, &plus_string                       # Using "+"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_1       # Using "sub_ebx,eax\nmov_eax,ebx\n"
	mov_ecx, &minus_string                      # Using "-"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_2       # Using "mul_ebx\n"
	mov_ecx, &multiply_string                   # Using "*"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_3       # Using "xchg_ebx,eax\nmov_edx, %0\ndiv_ebx\n"
	mov_ecx, &divide_string                     # Using "/"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_4       # Using "xchg_ebx,eax\nmov_edx, %0\ndiv_ebx\nmov_eax,edx\n"
	mov_ecx, &modulus_string                    # Using "%"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_5       # Using "mov_ecx,eax\nmov_eax,ebx\nsal_eax,cl\n"
	mov_ecx, &left_shift_string                 # Using "<<"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	mov_eax, &postfix_expr                      # Using postfix_expr
	mov_ebx, &additive_expr_stub_string_6       # Using "mov_ecx,eax\nmov_eax,ebx\nsar_eax,cl\n"
	mov_ecx, &right_shift_string                # Using ">>"
	mov_edx, &additive_expr_stub                # And recurse
	call %general_recursion                     # Hit it

	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:additive_expr_stub_string_0  "add_eax,ebx
"
:additive_expr_stub_string_1  "sub_ebx,eax
mov_eax,ebx
"
:additive_expr_stub_string_2  "mul_ebx
"
:additive_expr_stub_string_3  "xchg_ebx,eax
mov_edx, %0
div_ebx
"
:additive_expr_stub_string_4  "xchg_ebx,eax
mov_edx, %0
div_ebx
mov_eax,edx
"
:additive_expr_stub_string_5  "mov_ecx,eax
mov_eax,ebx
sal_eax,cl
"
:additive_expr_stub_string_6  "mov_ecx,eax
mov_eax,ebx
sar_eax,cl
"


# postfix_expr function
# Receives nothing
# Returns Nothing
# Walks global_token list and updates output list
# just calls other function
:postfix_expr
	call %primary_expr                          # Walk up the tree
	call %postfix_expr_stub                     # Recurse
	ret


# postfix_expr_stub function
# Receives nothing
# Returns Nothing
# Checks for "[" and "->" and deals with them otherwise does nothing
# Uses EAX, EBX, ECX and EDX for passing constants to general recursion
:postfix_expr_stub
	push_ebx                                    # Protect EBX
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &open_bracket                      # Using "["
	call %match                                 # IF global_token->S == "["
	cmp_eax, !0                                 # then we have an array
	jne %postfix_expr_stub_arrow                # Otherwise try arrow

	# Deal with array
	call %postfix_expr_array                    # Get it
	call %postfix_expr_stub                     # Recurse

:postfix_expr_stub_arrow
	mov_eax, &arrow_string                      # Using "->"
	call %match                                 # IF global_token->S == "->"
	cmp_eax, !0                                 # Then we need to deal with struct offsets
	jne %postfix_expr_stub_done                 # Otherwise be done

	# Deal with arrow
	call %postfix_expr_arrow                    # Get it
	call %postfix_expr_stub                     # Recurse

:postfix_expr_stub_done
	pop_ebx                                     # Restore EBX
	ret


# unary_expr_sizeof function
# Receives nothing
# Returns nothing
# Uses ECX for A->SIZE
:unary_expr_sizeof
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &unary_expr_sizeof_string_0        # Using "ERROR in unary_expr\nMissing (\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make sure we have it

	call %type_name                             # Get the type
	mov_ecx,[eax+BYTE] !4                       # Set A->TYPE

	mov_eax, &unary_expr_sizeof_string_1        # Using "ERROR in unary_expr\nMissing )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	mov_eax, &unary_expr_sizeof_string_2        # Using "mov_eax, %"
	call %emit_out                              # Emit it

	mov_eax,ecx                                 # Put A->SIZE in the right place
	call %numerate_number                       # Turn into string
	call %emit_out                              # Emit it

	mov_eax, &unary_expr_sizeof_string_3        # Using "\n"
	call %emit_out                              # Emit it

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:unary_expr_sizeof_string_0  "ERROR in unary_expr
Missing (
"
:unary_expr_sizeof_string_1  "ERROR in unary_expr
Missing )
"
:unary_expr_sizeof_string_2  "mov_eax, %"
:unary_expr_sizeof_string_3  "
"


# postfix_expr_array function
# Receives Nothing
# Returns Nothing
# Uses EBX for struct type* ARRAY and ECX for char* ASSIGN
:postfix_expr_array
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &current_target             # ARRAY = current_target
	push_eax                                    # Protect it

	mov_eax, &expression                        # Using expression
	call %common_recursion                      # Recurse

	pop_ebx                                     # Restore array
	mov_[DWORD],ebx &current_target             # current_target = ARRAY

	mov_ecx, &postfix_expr_array_string_0       # ASSIGN = "mov_eax,[eax]\n"

	mov_eax, &type_char_indirect_name           # Using "char*"
	mov_ebx,[ebx+BYTE] !24                      # current_target->NAME
	call %match                                 # IF current_target->NAME == "char*"
	cmp_eax, !0                                 # load a byte
	jne %postfix_expr_array_large               # Otherwise adjust

	# Deal with loading byte
	mov_ecx, &postfix_expr_array_string_1       # ASSIGN = "movsx_eax,BYTE_PTR_[eax]\n"
	jmp %postfix_expr_array_common              # Do the next bit

:postfix_expr_array_large
	# deal with arrays made of things other than chars
	mov_eax, &postfix_expr_array_string_2       # Using "sal_eax, !"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &current_target             # Using current_target
	mov_eax,[eax+BYTE] !12                      # current_target->INDIRECT
	mov_eax,[eax+BYTE] !4                       # current_target->INDIRECT->SIZE
	call %ceil_log2                             # ceil_log2(current_target->indirect->size)
	call %numerate_number                       # numerate_number(ceil_log2(current_target->indirect->size))
	call %emit_out                              # Emit it

	mov_eax, &postfix_expr_array_string_3       # Using "\n"
	call %emit_out                              # Emit it

:postfix_expr_array_common
	mov_eax, &postfix_expr_array_string_4       # Using "add_eax,ebx\n"
	call %emit_out                              # Emit it

	mov_eax, &postfix_expr_array_string_5       # Using "ERROR in postfix_expr\nMissing ]\n"
	mov_ebx, &close_bracket                     # Using "]"
	call %require_match                         # Make sure we have it

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &equal                             # Using "="
	call %match                                 # IF global_token->S == "="
	cmp_eax, !0                                 # We need to preserve address
	jne %postfix_expr_array_done                # Otherwise be done

	# Clearing out assign
	mov_ecx, &postfix_expr_array_string_6       # ASSIGN = ""

:postfix_expr_array_done
	mov_eax,ecx                                 # Using ASSIGN
	call %emit_out                              # Emit it

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:postfix_expr_array_string_0  "mov_eax,[eax]
"
:postfix_expr_array_string_1  "movsx_eax,BYTE_PTR_[eax]
"
:postfix_expr_array_string_2  "sal_eax, !"
:postfix_expr_array_string_3  "
"
:postfix_expr_array_string_4  "add_eax,ebx
"
:postfix_expr_array_string_5  "ERROR in postfix_expr
Missing ]
"
:postfix_expr_array_string_6  ""


# ceil_log2 function
# Receives int a in EAX
# Performs log2 on A and
# Returns result in EAX
# Uses EBX for INT A and ECX for INT RESULT
:ceil_log2
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx, %0                                 # RESULT = 0

	mov_ebx,eax                                 # put A in right place
	sub_eax, !1                                 # (A - 1)
	and_eax,ebx                                 # A & (A - 1)
	cmp_eax, !0                                 # IF 0 == (A & (A - 1))
	jne %ceil_log2_iter                         # Starting from -1

	mov_ecx, %-1                                # RESULT = -1

:ceil_log2_iter
	cmp_ebx, !0                                 # IF A > 0
	jle %ceil_log2_done                         # Otherwise be done

	add_ecx, !1                                 # RESULT = RESULT + 1
	shr_ebx, !1                                 # A = A >> 1
	jmp %ceil_log2_iter                         # Keep looping

:ceil_log2_done
	mov_eax,ecx                                 # Return RESULT
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# postfix_expr_arrow function
# Receives nothing
# Returns nothing
# Emits a bunch and updates current_target
# Uses EBX for struct type* I
:postfix_expr_arrow
	push_ebx                                    # Protect EBX
	mov_eax, &postfix_expr_arrow_string_0       # Using "# looking up offset\n"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_ebx,[eax+BYTE] !8                       # Using global_token->S
	mov_eax,[DWORD] &current_target             # Using current_target
	call %lookup_member                         # lookup_member(current_target, global_token->s)
	mov_ebx,eax                                 # struct type* I = lookup_member(current_target, global_token->s)

	mov_eax,[eax+BYTE] !20                      # I->TYPE
	mov_[DWORD],eax &current_target             # current_target = I->TYPE

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax,[ebx+BYTE] !8                       # I->OFFSET
	cmp_eax, !0                                 # IF 0 != I->OFFSET
	je %postfix_expr_arrow_first                # Then we don't need to do an offset

	# Deal with needing an offset
	mov_eax, &postfix_expr_arrow_string_1       # Using "# -> offset calculation\nmov_ebx, %"
	call %emit_out                              # Emit it

	mov_eax,[ebx+BYTE] !8                       # I->OFFSET
	call %numerate_number                       # Convert to string
	call %emit_out                              # Emit it

	mov_eax, &postfix_expr_arrow_string_2       # Using "\nadd_eax,ebx\n"
	call %emit_out                              # Emit it

:postfix_expr_arrow_first
	mov_eax,[ebx+BYTE] !4                       # I->SIZE
	cmp_eax, !4                                 # IF I->SIZE >= 4
	jl %postfix_expr_arrow_done                 # Otherwise be done

	# Last chance for load
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_ebx,[eax+BYTE] !8                       # global_token->S
	mov_eax, &equal                             # Using "="
	call %match                                 # IF global_token->S == "="
	cmp_eax, !0                                 # Then we have assignment and should not load
	je %postfix_expr_arrow_done                 # Be done

	# Deal with load case
	mov_eax, &postfix_expr_arrow_string_3       # Using "mov_eax,[eax]\n"
	call %emit_out                              # Emit it

:postfix_expr_arrow_done
	pop_ebx                                     # Restore EBX
	ret

:postfix_expr_arrow_string_0  "# looking up offset
"
:postfix_expr_arrow_string_1  "# -> offset calculation
mov_ebx, %"
:postfix_expr_arrow_string_2  "
add_eax,ebx
"
:postfix_expr_arrow_string_3  "mov_eax,[eax]
"


# primary_expr function
# Receives nothing
# Returns nothing
:primary_expr
	push_ebx                                    # Protect EBX

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_ebx,[eax+BYTE] !8                       # global_token->S
	mov_eax, &sizeof_string                     # Using "sizeof"
	call %match                                 # See if match
	cmp_eax, !0                                 # IF match
	jne %primary_expr_neg                       # Otherwise try negatives

	# Deal with sizeof
	call %unary_expr_sizeof                     # Lets do this
	jmp %primary_expr_done                      # Be done

:primary_expr_neg
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !45                                # IF global_token->S[0] == "-"
	jne %primary_expr_not                       # Otherwise try logical NOT

	# Deal with negative numbers
	mov_eax, &primary_expr_string_0             # Using "mov_eax, %0\n"
	call %emit_out                              # Emit it

	mov_eax, &postfix_expr                      # Passing postfix_expr
	call %common_recursion                      # Get what it is notting

	mov_eax, &primary_expr_string_1             # Using "sub_ebx,eax\nmov_eax,ebx\n"
	call %emit_out                              # Emit it
	jmp %primary_expr_done                      # Be done

:primary_expr_not
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !33                                # IF global_token->S[0] == "!"
	jne %primary_expr_bin                       # Otherwise try '~'

	# Deal with logical not
	mov_eax, &primary_expr_string_2             # Using "mov_eax, %1\n"
	call %emit_out                              # Emit it

	mov_eax, &postfix_expr                      # Passing postfix_expr
	call %common_recursion                      # Get what it is notting

	mov_eax, &primary_expr_string_3             # Using "xor_eax,ebx\n"
	call %emit_out                              # Emit it
	jmp %primary_expr_done                      # Be done

:primary_expr_bin
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !126                               # IF global_token->S[0] == "~"
	jne %primary_expr_paren                     # Otherwise try paren

	# Deal with binary NOT
	mov_eax, &postfix_expr                      # Passing postfix_expr
	call %common_recursion                      # Get what it is notting
	mov_eax, &primary_expr_string_4             # Using "not_eax\n"
	call %emit_out                              # Emit it
	jmp %primary_expr_done                      # Be done

:primary_expr_paren
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !40                                # IF global_token->S[0] == "("
	jne %primary_expr_ch                        # Otherwise try char

	# deal with nesting
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT
	call %expression                            # Lets recurse
	mov_eax, &primary_expr_string_5             # Using "Error in Primary expression\nDidn't get )\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it
	jmp %primary_expr_done                      # Be done

:primary_expr_ch
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !39                                # Using "'"
	jne %primary_expr_str                       # Otherwise try string

	# Deal with chars
	call %primary_expr_char                     # Handle that char
	jmp %primary_expr_done                      # Be done

:primary_expr_str
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !34                                # Using '\"'
	jne %primary_expr_var                       # Otherwise try a variable

	# Deal with strings
	call %primary_expr_string                   # Handle that string
	jmp %primary_expr_done                      # Be done

:primary_expr_var
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	mov_ebx, &primary_expr_string_6             # Using "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
	call %In_Set                                # See if we have a match
	cmp_eax, !1                                 # IF match
	jne %primary_expr_num                       # otherwise try number

	# Deal with variables
	call %primary_expr_variable                 # Deal with variable
	jmp %primary_expr_done                      # Be done

:primary_expr_num
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	mov_ebx, &primary_expr_string_7             # Using "0123456789"
	call %In_Set                                # See if we have a match
	cmp_eax, !1                                 # IF match
	jne %primary_expr_fail                      # otherwise we failed hard

	# Deal with numbers
	call %primary_expr_number                   # Collect the number
	jmp %primary_expr_done                      # Be done

:primary_expr_fail
	# looks like we hit bad input
	# abort before it gets bad
	call %primary_expr_failure                  # No match means failure
:primary_expr_done
	pop_ebx                                     # Restore EBX
	ret

:primary_expr_string_0  "mov_eax, %0
"
:primary_expr_string_1  "sub_ebx,eax
mov_eax,ebx
"
:primary_expr_string_2  "mov_eax, %1
"
:primary_expr_string_3  "xor_eax,ebx
"
:primary_expr_string_4  "not_eax
"
:primary_expr_string_5  "Error in Primary expression
Didn't get )
"
:primary_expr_string_6  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
:primary_expr_string_7  "0123456789"


# primary_expr_variable function
# Receives nothing
# Returns nothing
# Walks global and updates output
# Uses EAX for struct token_list* a and ECX for char* S
:primary_expr_variable
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_ecx,[eax+BYTE] !8                       # S = global_token->S
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax,ecx                                 # Using S
	mov_ebx,[DWORD] &global_constant_list       # Using global_constant_list
	call %sym_lookup                            # sym_lookup(s, global_constant_list)
	cmp_eax, !0                                 # IF NULL == sym_lookup(s, global_constant_list)
	je %primary_expr_variable_local             # Try locals next

	# Deal with constant load
	mov_ebx,[eax+BYTE] !16                      # a->ARGS
	mov_eax, &primary_expr_variable_string_2    # Using "mov_eax, %"
	call %emit_out                              # Emit it

	mov_eax,[ebx+BYTE] !8                       # a->ARGS->S
	call %emit_out                              # Emit it

	mov_eax, &primary_expr_variable_string_1    # Using "\n"
	call %emit_out                              # Emit it
	jmp %primary_expr_variable_done             # Be done

:primary_expr_variable_local
	mov_eax,ecx                                 # Using S
	mov_ebx,[DWORD] &function                   # Using function
	mov_ebx,[ebx+BYTE] !4                       # function->locals
	call %sym_lookup                            # sym_lookup(s, function->locals)
	cmp_eax, !0                                 # IF NULL == sym_lookup(s, function->locals)
	je %primary_expr_variable_arguments         # try arguments next

	# Deal with local load
	call %variable_load                         # Collect it
	jmp %primary_expr_variable_done             # Be done

:primary_expr_variable_arguments
	mov_eax,ecx                                 # Using S
	mov_ebx,[DWORD] &function                   # Using function
	mov_ebx,[ebx+BYTE] !16                      # function->args
	call %sym_lookup                            # sym_lookup(s, function->args)
	cmp_eax, !0                                 # IF NULL == sym_lookup(s, global_constant_list)
	je %primary_expr_variable_function          # try functions next

	# Deal with argument load
	call %variable_load                         # Collect it
	jmp %primary_expr_variable_done             # Be done

:primary_expr_variable_function
	mov_eax,ecx                                 # Using S
	mov_ebx,[DWORD] &global_function_list       # Using global_function_list
	call %sym_lookup                            # sym_lookup(s, global_function_list)
	cmp_eax, !0                                 # IF NULL == sym_lookup(s, global_function_list)
	je %primary_expr_variable_global            # try globals next

	# Deal with functions
	call %function_load                         # Deal with the function
	jmp %primary_expr_variable_done             # Be done

:primary_expr_variable_global
	mov_eax,ecx                                 # Using S
	mov_ebx,[DWORD] &global_symbol_list         # Using global_symbol_list
	call %sym_lookup                            # sym_lookup(s, global_symbol_list)
	cmp_eax, !0                                 # IF NULL == sym_lookup(s, global_symbol_list)
	je %primary_expr_variable_error             # Give up

	# Deal with globals
	call %global_load                           # Collect that global
	jmp %primary_expr_variable_done             # Be done

:primary_expr_variable_error
	mov_eax, %2                                 # Using standard error
	mov_[DWORD],eax &Output_file                # write to standard error
#	call %line_error                            # Write useful debug info
	mov_eax,ecx                                 # put S in the right place
	call %File_Print                            # print it

	mov_eax, &primary_expr_variable_string_0    # Ending string
	call %File_Print                            # print it
	jmp %Exit_Failure                           # Abort Hard

:primary_expr_variable_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:primary_expr_variable_string_0  " is not a defined symbol
"
:primary_expr_variable_string_1  "
"
:primary_expr_variable_string_2  "mov_eax, %"


# function_call function
# Receives char* S in EAX and int BOOL in EBX
# Builds stack frames before and tears them down after function calls
# Uses ECX for char* S, EDX for int BOOL, ESI for PASSED
:function_call
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_esi                                    # Protect ESI
	mov_ecx,eax                                 # Put S in place
	mov_edx,ebx                                 # Put BOOL in place
	mov_esi, %0                                 # PASSED = 0

	mov_eax, &function_call_string_0            # Using "ERROR in process_expression_list\nNo ( was found\n"
	mov_ebx, &open_paren                        # Using "("
	call %require_match                         # Make sure we have it

	mov_eax, &function_call_string_1            # Using "push_edi\t# Prevent overwriting in recursion\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_2            # Using "push_ebp\t# Protect the old base pointer\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_3            # Using "mov_edi,esp\t# Copy new base pointer\n"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !41                                # IF global_token->S[0] == ")"
	je %function_call_gen_done                  # Then no arguments to send

	# looks like we have arguments to collect
	call %expression                            # Collect the argument

	mov_eax, &function_call_string_4            # Using "push_eax\t#_process_expression1\n"
	call %emit_out                              # Emit it
	mov_esi, %1                                 # PASSED = 1

:function_call_gen_iter
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !44                                # IF global_token->S[0] == ","
	jne %function_call_gen_done                 # Otherwise we are done

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	call %expression                            # Collect the argument

	mov_eax, &function_call_string_5            # Using "push_eax\t#_process_expression2\n"
	call %emit_out                              # Emit it
	add_esi, !1                                 # PASSED = PASSED + 1
	jmp %function_call_gen_iter                 # Keep trying

:function_call_gen_done
	# All is collected
	mov_eax, &function_call_string_6            # Using "ERROR in process_expression_list\nNo ) was found\n"
	mov_ebx, &close_paren                       # Using ")"
	call %require_match                         # Make sure we have it

	cmp_edx, !0                                 # IF(BOOL == TRUE)
	jne %function_call_static                   # Otherwise it is a static call

	# Deal with a passed function pointer
	mov_eax, &function_call_string_7            # Using "lea_eax,[ebp+DWORD] %"
	call %emit_out                              # Emit it

	mov_eax,ecx                                 # Using S
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_8            # Using "\nmov_eax,[eax]\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_9            # Using "mov_ebp,edi\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_10           # Using "call_eax\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_13           # Using "pop_ebx\t# _process_expression_locals\n"
	jmp %function_call_cleanup                  # Clean up

:function_call_static
	# Deal with fixed function name
	mov_eax, &function_call_string_9            # Using "mov_ebp,edi\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_11           # Using "call %FUNCTION_"
	call %emit_out                              # Emit it

	mov_eax,ecx                                 # Using S
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_12           # Using "\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_13           # Using "pop_ebx\t# _process_expression_locals\n"

:function_call_cleanup
	cmp_esi, !0                                 # IF PASSED > 0
	jle %function_call_done                     # Otherwise be done

	# The desired string is already in EAX
	call %emit_out                              # Emit it

	sub_esi, !1                                 # PASSED = PASSED - 1
	jmp %function_call_cleanup                  # Keep going

:function_call_done
	mov_eax, &function_call_string_14           # Using "pop_ebp\t# Restore old base pointer\n"
	call %emit_out                              # Emit it

	mov_eax, &function_call_string_15           # Using "pop_edi\t# Prevent overwrite\n"
	call %emit_out                              # Emit it

	pop_esi                                     # Restore ESI
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:function_call_string_0  "ERROR in process_expression_list
No ( was found
"
:function_call_string_1  "push_edi	# Prevent overwriting in recursion
"
:function_call_string_2  "push_ebp	# Protect the old base pointer
"
:function_call_string_3  "mov_edi,esp	# Copy new base pointer
"
:function_call_string_4  "push_eax	#_process_expression1
"
:function_call_string_5  "push_eax	#_process_expression2
"
:function_call_string_6  "ERROR in process_expression_list
No ) was found
"
:function_call_string_7  "lea_eax,[ebp+DWORD] %"
:function_call_string_8  "
mov_eax,[eax]
"
:function_call_string_9  "mov_ebp,edi
"
:function_call_string_10 "call_eax
"
:function_call_string_11 "call %FUNCTION_"
:function_call_string_12 "
"
:function_call_string_13 "pop_ebx	# _process_expression_locals
"
:function_call_string_14 "pop_ebp	# Restore old base pointer
"
:function_call_string_15 "pop_edi	# Prevent overwrite
"


# variable_load function
# Receives struct token_list* A in EAX
# Returns nothing
# Updates output and current_target
# Uses ECX for A
:variable_load
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # Protect A

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &open_paren                        # Using "("
	call %match                                 # IF global_token->S == "("
	cmp_eax, !0                                 # Then it might be a function
	jne %variable_load_regular                  # Otherwise it is regular

	mov_ebx,[ecx+BYTE] !12                      # A->TYPE
	mov_ebx,[ebx+BYTE] !24                      # A->TYPE->NAME
	mov_eax, &type_function_name                # Using "FUNCTION"
	call %match                                 # IF A->TYPE->NAME == "FUNCTION"
	cmp_eax, !0                                 # Then it must be a function
	jne %variable_load_regular                  # otherwise just another regular

	# deal with function
	mov_eax,[ecx+BYTE] !16                      # A->DEPTH
	call %numerate_number                       # Convert to string
	mov_ebx, %0                                 # pass 0 for true
	call %function_call                         # Create the function call
	jmp %variable_load_done                     # Be done

:variable_load_regular
	mov_eax,[ecx+BYTE] !12                      # A->TYPE
	mov_[DWORD],eax &current_target             # current_target = A->TYPE

	mov_eax, &variable_load_string_0            # Using "lea_eax,[ebp+DWORD] %"
	call %emit_out                              # Emit it

	mov_eax,[ecx+BYTE] !16                      # A->DEPTH
	call %numerate_number                       # Convert to string
	call %emit_out                              # Emit it

	mov_eax, &variable_load_string_1            # Using "\n"
	call %emit_out                              # Emit it

	# Check for special case of assignment
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &equal                             # Using "="
	call %match                                 # IF global_token->S == "="
	cmp_eax, !0                                 # Then we skip loading
	je %variable_load_done                      # And be done

	# Deal with common case
	mov_eax, &variable_load_string_2            # Using "mov_eax,[eax]\n"
	call %emit_out                              # Emit it

:variable_load_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:variable_load_string_0  "lea_eax,[ebp+DWORD] %"
:variable_load_string_1  "
"
:variable_load_string_2  "mov_eax,[eax]
"


# function_load function
# Receives struct token_list* a in EAX
# Returns nothing
# Uses ECX to hold A->S
:function_load
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax,[eax+BYTE] !8                       # A->S
	mov_ecx,eax                                 # Protect A->S
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &open_paren                        # Using "("
	call %match                                 # IF global_token->S == "("
	cmp_eax, !0                                 # The we need to do a function call
	jne %function_load_regular                  # Otherwise just load it's address

	# Deal with function call
	mov_eax,ecx                                 # Using A->S
	mov_ebx, %1                                 # Using FALSE
	call %function_call                         # Deal with it
	jmp %function_load_done                     # Be done

:function_load_regular
	mov_eax, &function_load_string_0            # Using "mov_eax, &FUNCTION_"
	call %emit_out                              # Emit it

	mov_eax,ecx                                 # Using A->S
	call %emit_out                              # Emit it

	mov_eax, &function_load_string_1            # Using "\n"
	call %emit_out                              # Emit it

:function_load_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:function_load_string_0  "mov_eax, &FUNCTION_"
:function_load_string_1  "
"


# global_load function
# Receives struct token_list* A in EAX
# Returns nothing
# Uses EBX to hold A->S
:global_load
	push_ebx                                    # Protect EBX
	mov_ebx,eax                                 # Set as A
	mov_ebx,[ebx+BYTE] !8                       # Set as A->S

	mov_eax,[eax+BYTE] !12                      # A->TYPE
	mov_[DWORD],eax &current_target             # current_target = A->TYPE

	mov_eax, &global_load_string_0              # Using "mov_eax, &GLOBAL_"
	call %emit_out                              # Emit it

	mov_eax,ebx                                 # Using A->S
	call %emit_out                              # Emit it

	mov_eax, &global_load_string_1              # Using "\n"
	call %emit_out                              # Emit it

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &equal                             # "="
	call %match                                 # IF global_token->S == "="
	cmp_eax, !0                                 # We need to skip for assignment
	je %global_load_done                        # and be done

	# Otherwise we are loading the contents
	mov_eax, &global_load_string_2              # Using "mov_eax,[eax]\n"
	call %emit_out                              # Emit it

:global_load_done
	pop_ebx                                     # Restore EBX
	ret

:global_load_string_0  "mov_eax, &GLOBAL_"
:global_load_string_1  "
"
:global_load_string_2  "mov_eax,[eax]
"


# sym_lookup function
# Receives char* S in EAX and struct token_list* symbol_list in EBX
# Uses I->S in EAX, S in EBX and I in ECX
# Returns match or NULL
:sym_lookup
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,ebx                                 # I = symbol_list
	mov_ebx,eax                                 # Put S in the right place
:sym_lookup_iter
	cmp_ecx, !0                                 # IF NULL == I
	je %sym_lookup_done                         # We failed to find match

	mov_eax,[ecx+BYTE] !8                       # Using I->S
	call %match                                 # IF I->S == S
	cmp_eax, !0                                 # then be done
	je %sym_lookup_done                         # Failed

	mov_ecx,[ecx]                               # I = I->NEXT
	jmp %sym_lookup_iter                        # otherwise keep looping

:sym_lookup_done
	mov_eax,ecx                                 # Return I
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# primary_expr_number function
# Receives nothing
# Returns nothing
# Simply uses current global token to update output and then steps to next global_token
:primary_expr_number
	mov_eax, &primary_expr_number_string_0      # Using "mov_eax, %"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %emit_out                              # Emit it

	mov_eax, &primary_expr_number_string_1      # Using "\n"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT
	ret

:primary_expr_number_string_0  "mov_eax, %"
:primary_expr_number_string_1  "
"


# primary_expr_string function
# receives nothing
# Returns nothing
# creates entries for string and calls to generate string output
# uses ECX for char* number_string
:primary_expr_string
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ebx,[DWORD] &current_count              # Using current_count
	mov_eax,ebx                                 # And putting it in the right place
	call %numerate_number                       # Get the string
	mov_ecx,eax                                 # protect number_string

	add_ebx, !1                                 # current_count + 1
	mov_[DWORD],ebx &current_count              # current_count = current_count + 1

	mov_eax, &primary_expr_string_string_0      # Using "mov_eax, &STRING_"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	mov_ebx,ecx                                 # Put number_string in the right place
	call %uniqueID_out                          # Make it unique

	# Generate the target
	mov_eax, &primary_expr_string_string_1      # Using ":STRING_"
	mov_ebx,[DWORD] &strings_list               # Using strings_list
	call %emit                                  # Emit it
	mov_ebx,eax                                 # put new strings_list in place

	mov_eax,[DWORD] &function                   # Using function
	mov_eax,[eax+BYTE] !8                       # function->S
	call %uniqueID                              # Make it unique
	mov_ebx,eax                                 # put new strings_list in place

	# Parse the string
	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %parse_string                          # convert to useful form
	call %emit                                  # Emit it
	mov_[DWORD],eax &strings_list               # Update Strings _list

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:primary_expr_string_string_0  "mov_eax, &STRING_"
:primary_expr_string_string_1  ":STRING_"


# primary_expr_char function
# Receives nothing
# Returns nothing
# Updates output_list using global_token
:primary_expr_char
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_eax, &primary_expr_char_string_0        # Using "mov_eax, %"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	add_eax, !1                                 # global_token->S + 1
	call %escape_lookup                         # Get the char
	call %numerate_number                       # Convert to string
	call %emit_out                              # emit it

	mov_eax, &primary_expr_char_string_1        # Using "\n"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:primary_expr_char_string_0  "mov_eax, %"
:primary_expr_char_string_1  "
"


# primary_expr_failure function
# Receives nothing
# Does not return but aborts hard
# Complains about the bad input
:primary_expr_failure
#	call %line_error                            # Get line of issue
	mov_eax, %2                                 # Using Standard error
	mov_[DWORD],eax &Output_file                # write to standard error
	mov_eax, &primary_expr_failure_string_0     # Using "Received "
	call %File_Print                            # Print it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %File_Print                            # Print it

	mov_eax, &primary_expr_failure_string_1     # Using " in primary_expr\n"
	call %File_Print                            # Print it
	jmp %Exit_Failure                           # Abort Hard

:primary_expr_failure_string_0  "Received "
:primary_expr_failure_string_1  " in primary_expr
"


# general_recursion function
# Receives FUNCTION F in EAX, char* S in EBX, char* name in ECX and FUNCTION iterate in EDX
# Returns nothing
# Uses ECX for char* S, EDX for FUNCTION iterate and EBP for FUNCTION F
# But generally recurses a shitload
:general_recursion
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_ebp                                    # Protect EBP
	mov_ebp,eax                                 # Protect F
	mov_eax,ecx                                 # Put name in the right place
	mov_ecx,ebx                                 # Protect S

	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	call %match                                 # IF match(name, global_token->s)
	cmp_eax, !0                                 # If true we do
	jne %general_recursion_done                 # Otherwise skip it

	# Deal with the recursion
	mov_eax,ebp                                 # Put F in the right place
	call %common_recursion                      # Recurse

	mov_eax,ecx                                 # Put S in the right place
	call %emit_out                              # Emit it

	mov_eax,edx                                 # Put iterate in the right place
	call_eax                                    # Down the rabbit hole

:general_recursion_done
	pop_ebp                                     # Restore EBP
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# promote_type function
# Receives struct type* a in EAX and struct type* b in EBX
# Returns the most recent type in EAX
# Uses EAX for struct type* I, ECX for struct type* A and EDX for struct type* B
:promote_type
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	cmp_ebx, !0                                 # IF NULL == B
	je %promote_type_done                       # Just return A

	mov_ecx,eax                                 # Put A in place
	mov_edx,ebx                                 # Put B in place
	mov_eax,ebx                                 # IF NULL == A
	cmp_ecx, !0                                 # Then we just return B
	je %promote_type_done                       # Be done

	# Looks like we need to walk the list
	mov_ecx,[ecx+BYTE] !24                      # A->NAME
	mov_edx,[edx+BYTE] !24                      # B->NAME
	mov_eax,[DWORD] &global_types               # I = global_types
:promote_type_iter
	cmp_eax, !0                                 # IF NULL == I
	je %promote_type_done                       # Just be done

	mov_ebx,[eax+BYTE] !24                      # I->NAME
	cmp_ebx,ecx                                 # IF(A->NAME == I->NAME)
	je %promote_type_done                       # Be done

	cmp_ebx,edx                                 # IF(B->NAME == I->NAME)
	je %promote_type_done                       # Be done

	mov_ebx,[eax+BYTE] !12                      # I->INDIRECT
	mov_ebx,[ebx+BYTE] !24                      # I->INDIRECT->NAME

	cmp_ebx,ecx                                 # IF(A->NAME == I->INDIRECT->NAME)
	je %promote_type_done                       # Be done

	cmp_ebx,edx                                 # IF(B->NAME == I->INDIRECT->NAME)
	je %promote_type_done                       # Be done

	mov_eax,[eax]                               # I = I->NEXT
	jmp %promote_type_iter                      # Keep going

:promote_type_done
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# common_recursion function
# Receives FUNCTION F in EAX
# Returns Nothing
# Walks global_token list and update output_list
# Updates current_target
# Uses EBX to hold FUNCTION F and struct type* last_type
:common_recursion
	push_ebx                                    # Protect EBX
	mov_ebx,eax                                 # Put FUNCTION F safely out of the way
	mov_eax, &common_recursion_string_0         # Using "push_eax\t#_common_recursion\n"
	call %emit_out                              # Emit it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax,ebx                                 # Prepare for function call
	mov_ebx,[DWORD] &current_target             # Get last type
	call_eax                                    # F();
	mov_eax,[DWORD] &current_target             # Get current_target
	call %promote_type                          # get the right type
	mov_[DWORD],eax &current_target             # Set new current_target

	mov_eax, &common_recursion_string_1         # Using "pop_ebx\t# _common_recursion\n"
	call %emit_out                              # Emit it
	pop_ebx                                     # Restore EBX
	ret

:common_recursion_string_0  "push_eax	#_common_recursion
"
:common_recursion_string_1  "pop_ebx	# _common_recursion
"


# require_match function
# Receives char* message in EAX and char* required in EBX
# Returns nothing
# Uses ECX to hold message and updates global_token
:require_match
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # put the message somewhere safe
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %match                                 # IF required == global_token->S
	cmp_eax, !0                                 # we are fine
	je %require_match_good                      # otherwise pain

	# Deal will bad times
#	call %line_error                            # Tell user what went wrong
	mov_eax, %2                                 # Using standard error
	mov_[DWORD],eax &Output_file                # write to standard error
	mov_eax,ecx                                 # using our message
	call %File_Print                            # Print it
	jmp %Exit_Failure                           # Abort HARD

:require_match_good
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->next
	mov_[DWORD],eax &global_token               # global_token = global_token->next
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# uniqueID Function
# Receives char *S in EAX, struct token_list* l in EBX and char* num in ECX
# Returns updated struct token_list* L in EAX
:uniqueID
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	call %emit                                  # emit(s, l)
	mov_ebx,eax                                 # Put L in correct place
	mov_eax, &underline                         # Using "_"
	call %emit                                  # emit("_", l)
	mov_ebx,eax                                 # Put L in correct place
	mov_eax,ecx                                 # Put num in correct place
	call %emit                                  # emit(num, l)
	mov_ebx,eax                                 # Put L in correct place
	mov_eax, &uniqueID_string_0                 # Using "\n"
	call %emit                                  # emit("\n", l)
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:uniqueID_string_0  "
"


# uniqueID_out function
# Receives char* S in EAX and char* num in EBX
# Returns nothing
:uniqueID_out
	push_eax                                    # Protect EAX
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,ebx                                 # Put num in right spot
	mov_ebx,[DWORD] &output_list                # Using output_list
	call %uniqueID                              # Get updated list
	mov_[DWORD],eax &output_list                # output_list = uniqueID(s, output_list, num)
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	pop_eax                                     # Restore EAX
	ret


# emit_out function
# Receives char* S in EAX
# Returns nothing
# Updates output_list
# MUST NOT ALTER REGISTERS
:emit_out
	push_eax                                    # Protect EAX
	push_ebx                                    # Protect EBX
	mov_ebx,[DWORD] &output_list                # Using output_list
	call %emit                                  # emit it
	mov_[DWORD],eax &output_list                # update it
	pop_ebx                                     # Restore EBX
	pop_eax                                     # Restore EAX
	ret


# emit function
# Receives char *s in EAX and struct token_list* head in EBX
# Returns struct token_list* T in EAX
:emit
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # put S out of the way
	mov_eax, %20                                # sizeof(struct token_list)
	call %malloc                                # get T
	mov_[eax],ebx                               # t->next = head;
	mov_[eax+BYTE],ecx !8                       # t->s = s;
	pop_ecx                                     # Restore ECX
	ret


# escape_lookup function
# Receives char* c in EAX
# Returns integer value of char in EAX
# Aborts hard if unknown escape is received
# Uses ECX to hold char* C
:escape_lookup
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # Put char* C in safe place
	mov_al,[ecx]                                # Load c[0]
	movzx_eax,al                                # make it useful
	cmp_eax, !92                                # If '\\' != c[0]
	jne %escape_lookup_done                     # Be done

	mov_ebx,ecx                                 # Prepare for walk
	add_ebx, !1                                 # increment
	mov_bl,[ebx]                                # load c[1]
	movzx_ebx,bl                                # make it useful

	cmp_ebx, !120                               # Check if \x??
	je %escape_lookup_hex                       # Deal with hex

	# Deal with \? escapes
	mov_eax, %10                                # Guess "\n"
	cmp_ebx, !110                               # If n
	je %escape_lookup_done                      # Be done

	mov_eax, %9                                 # Guess "\t"
	cmp_ebx, !116                               # If t
	je %escape_lookup_done                      # Be done

	mov_eax,ebx                                 # "\\", "'" and '\"' all encode as themselves
	cmp_ebx, !92                                # If "\\"
	je %escape_lookup_done                      # Be done
	cmp_ebx, !39                                # IF "'"
	je %escape_lookup_done                      # Be done
	cmp_ebx, !34                                # IF '\"'
	je %escape_lookup_done                      # Be done

	mov_eax, %13                                # Guess "\r"
	cmp_ebx, !114                               # IF r
	je %escape_lookup_done                      # Be done

	# Looks like we have no clue what we are doing
	# Aborting hard
	mov_eax, %2                                 # Using Standard error
	mov_[DWORD],eax &Output_file                # write to standard error
	mov_eax, &escape_lookup_string_0            # Using "Unknown escape received: "
	call %File_Print                            # Print it
	mov_eax,ecx                                 # Using C
	call %File_Print                            # Print it
	mov_eax, &escape_lookup_string_1            # Using " Unable to process\n"
	call %File_Print                            # Print it
	jmp %Exit_Failure                           # Abort Hard

:escape_lookup_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:escape_lookup_hex
	# Give up on C and just assume they know what they are doing
	add_ecx, !2                                 # increment
	mov_al,[ecx]                                # c[2]
	movzx_eax,al                                # make it useful
	add_ecx, !1                                 # increment
	call %char2hex                              # Get the hex value
	sal_eax, !4                                 # c << 4
	mov_bl,[ecx]                                # c[3]
	movzx_ebx,bl                                # make it useful
	xchg_eax,ebx                                # protect c << 4
	call %char2hex                              # Get the hex value
	add_eax,ebx                                 # hex(c[2]) << 4 + hex(c[3])
	jmp %escape_lookup_done                     # Be done

:escape_lookup_string_0  "Unknown escape received: "
:escape_lookup_string_1  " Unable to process
"


# char2hex function
# Receives char in EAX
# Returns hex or aborts hard
:char2hex
	sub_eax, !48                                # Try 0-9
	cmp_eax, !10                                # Otherwise fun times
	jl %char2hex_done                           # Be done

	# Deal with A-F
	and_eax, %0xDF                              # Unset High bit turning a-f into A-F
	sub_eax, !7                                 # Shift down into position
	cmp_eax, !10                                # Everything below A is bad
	jl %char2hex_fail                           # And should fail
	cmp_eax, !16                                # Make sure we are below F
	jl %char2hex_done                           # If so be done

:char2hex_fail
	# Time to fail hard
	mov_eax, %2                                 # Using Standard error
	mov_[DWORD],eax &Output_file                # write to standard error
	mov_eax, &char2hex_string_0                 # Using "Tried to print non-hex number\n"
	call %File_Print                            # Print it
	jmp %Exit_Failure                           # Abort Hard

:char2hex_done
	ret

:char2hex_string_0  "Tried to print non-hex number
"


# parse_string function
# Receives char* string in EAX
# Returns cleaned up string
# Protects char* string in EBX
:parse_string
	push_ebx                                    # Protect EBX
	mov_ebx,eax                                 # Protect char* string
	call %weird                                 # Determine if we have a weird string
	cmp_eax, !0                                 # If weird
	je %parse_string_weird                      # Deal with it

	# Dealing with regular string
	mov_eax,ebx                                 # Passing Char* string
	call %collect_regular_string                # Collect it
	jmp %parse_string_done                      # Be done

:parse_string_weird
	mov_eax,ebx                                 # Passing Char* string
	call %collect_weird_string                  # Collect it

:parse_string_done
	pop_ebx                                     # Restore EBX
	ret


# weird function
# Receives char* string in EAX
# Returns true(0) or false(1) in EAX
# Uses ECX to hold char* string
:weird
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,eax                                 # Place string in safe place
	add_ecx, !1                                 # increment past the '\"'
:weird_reset
	mov_al,[ecx]                                # Load a char
	movzx_eax,al                                # Make it useful
	cmp_eax, !0                                 # IF NULL == C
	je %weird_false                             # Nothing weird found

	cmp_eax, !92                                # IF '\\'
	jne %weird_escaped                          # Deal with escaping

	# Deal with escape
	mov_eax,ecx                                 # We are passing the string
	call %escape_lookup                         # to look it up

	add_ecx, !1                                 # string = string + 1
	mov_bl,[ecx]                                # get string[1]
	movzx_ebx,bl                                # make it useful
	cmp_ebx, !120                               # IF 'x' == string[1]
	jne %weird_escaped                          # otherwise skip the gap

	add_ecx, !2                                 # string = string + 2

:weird_escaped
	push_eax                                    # Protect C in case we need it
	mov_ebx, &weird_string_0                    # Use "\t\n !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	call %In_Set                                # To find if weird
	cmp_eax, !1                                 # IF TRUE
	pop_eax                                     # Restore C
	jne %weird_true                             # Then not weird

	add_ecx, !1                                 # string = string + 1

	# Last chance for weird
	mov_ebx, &weird_string_1                    # Use "\t\n\r "
	call %In_Set                                # Check for special case
	cmp_eax, !1                                 # IF TRUE
	jne %weird_reset                            # Otherwise not in the special case

	# Deal with possible special case
	mov_al,[ecx]                                # Load string[1]
	movzx_eax,al                                # Make it useful
	cmp_eax, !58                                # IF string[1] == ":"
	je %weird_true                              # Then we hit the special case
	jmp %weird_reset                            # Keep trying

:weird_done
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:weird_true
	mov_eax, %0                                 # Return true
	jmp %weird_done                             # Be done

:weird_false
	mov_eax, %1                                 # Return false
	jmp %weird_done                             # Be done

:weird_string_0  "	
 !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
:weird_string_1  '09 0A 0D 20' ; "\t\n\r "


# collect_regular_string function
# Receives char* string in EAX
# Malloc and creates new string to return in EAX
# Uses ECX for return string and EDX for passed string
:collect_regular_string
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_edx,eax                                 # Protect our passed string
	mov_eax, %256                               # We need 256 bytes of storage
	call %malloc                                # Get our new pointer
	mov_ecx,eax                                 # put it in place
	push_eax                                    # protect until done
:collect_regular_string_reset
	mov_al,[edx]                                # string[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !0                                 # See if we hit the end
	je %collect_regular_string_done             # And be done

	cmp_eax, !92                                # IF string[0] == '\\'
	je %collect_regular_string_escaped          # Deal with that mess

	# deal with boring char
	mov_[ecx],al                                # hold_string[index] = string[0]
	add_ecx, !1                                 # Increment it
	add_edx, !1                                 # Increment it
	jmp %collect_regular_string_reset           # And keep going

:collect_regular_string_escaped
	mov_eax,edx                                 # Using string
	call %escape_lookup                         # Get the char
	mov_[ecx],al                                # hold_string[index] = escape_lookup(string)
	add_edx, !1                                 # Increment it
	add_ecx, !1                                 # Increment it
	mov_al,[edx]                                # string[0]
	movzx_eax,al                                # Make it useful
	add_edx, !1                                 # Increment it
	cmp_eax, !120                               # IF 'x' == string[1]
	jne %collect_regular_string_reset           # Otherwise keep going

	add_edx, !2                                 # Increment it
	jmp %collect_regular_string_reset           # Keep going

:collect_regular_string_done
	mov_eax, %34                                # Using '\"'
	mov_[ecx],al                                # hold_string[index] = '\"'
	add_ecx, !1                                 # Increment it
	mov_eax, %10                                # Using "\n"
	mov_[ecx],al                                # hold_string[index] = '\n'
	pop_eax                                     # Return our new string
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# collect_weird_string function
# Receives char* string in EAX
# Mallocs and returns char* hold in EAX
# Uses ECX for char* hold and EDX for char* string
:collect_weird_string
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_edx,eax                                 # Protect our passed string
	mov_eax, %512                               # We need 512 bytes of storage
	call %malloc                                # Get our new pointer
	mov_ecx,eax                                 # put it in place
	push_eax                                    # protect until done

	mov_eax, %39                                # Using "'"
	mov_[ecx],al                                # hold_string[index] = "'"
	add_ecx, !1                                 # Increment it
	add_edx, !1                                 # Increment it
:collect_weird_string_reset
	mov_al,[edx]                                # Read a byte
	movzx_eax,al                                # Make it useful
	cmp_eax, !0                                 # IF NULL == string[0]
	je %collect_weird_string_done               # Be done

	mov_eax, %32                                # Using ' '
	mov_[ecx],al                                # hold_string[index] = ' '
	add_ecx, !1                                 # Increment it

	mov_eax,edx                                 # Using string
	call %escape_lookup                         # Get the char
	call %hex8                                  # Update ECX

	mov_al,[edx]                                # Read a byte
	movzx_eax,al                                # Make it useful
	add_edx, !1                                 # Increment it
	cmp_eax, !92                                # IF string[0] == '\\'
	jne %collect_weird_string_reset             # Otherwise keep going

	mov_al,[edx]                                # Read a byte
	movzx_eax,al                                # Make it useful
	add_edx, !1                                 # Increment it
	cmp_eax, !120                               # IF 'x' == string[1]
	jne %collect_weird_string_reset             # Otherwise keep going

	add_edx, !2                                 # Increment it
	jmp %collect_weird_string_reset             # Keep going

:collect_weird_string_done
	mov_eax, %32                                # Using ' '
	mov_[ecx],al                                # hold_string[index] = ' '
	add_ecx, !1                                 # Increment it
	mov_eax, %48                                # Using '0'
	mov_[ecx],al                                # hold_string[index] = '0'
	add_ecx, !1                                 # Increment it
	mov_[ecx],al                                # hold_string[index] = '0'
	add_ecx, !1                                 # Increment it
	mov_eax, %39                                # Using "'"
	mov_[ecx],al                                # hold_string[index] = "'"
	add_ecx, !1                                 # Increment it
	mov_eax, %10                                # Using "\n"
	mov_[ecx],al                                # hold_string[index] = '\n'
	pop_eax                                     # Return our new string
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# HEX to ascii routine
# Receives INT in EAX and CHAR* in ECX
# Stores ascii of INT in CHAR*
# Returns only modifying EAX and ECX
:hex8
	push_eax                                    # Protect bottom nibble
	shr_eax, !4                                 # do high nibble first
	call %hex4                                  # Store it
	pop_eax                                     # do low nibble
:hex4
	and_eax, %0xF                               # isolate nibble
	add_eax, !48                                # convert to ascii
	cmp_eax, !57                                # valid digit?
	jbe8 !hex1                                  # yes
	add_eax, !7                                 # use alpha range
:hex1
	mov_[ecx],al                                # store result
	add_ecx, !1                                 # next position
	ret


# type_name function
# Receives nothing
# Returns type_size in EAX
# Uses ECX for STRUCT TYPE* RET
:type_name
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx+BYTE] !8                       # global_token->S
	mov_eax, &struct                            # Using "struct"
	call %match                                 # IF global_token->S == "struct"
	mov_ecx,eax                                 # Protect structure
	cmp_eax, !0                                 # need to skip over "struct"
	jne %type_name_native                       # otherwise keep going

	# Deal with possible STRUCTs
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx]                               # global_token->next
	mov_[DWORD],ebx &global_token               # global_token = global_token->next
	mov_eax,[ebx+BYTE] !8                       # global_token->S
	mov_ebx,[DWORD] &global_types               # get all known types
	call %lookup_type                           # Find type if possible
	mov_ecx,eax                                 # Set ret

	cmp_eax, !0                                 # IF NULL == ret
	jne %type_name_common                       # We have to create struct

	# Create a struct
	call %create_struct                         # Create a new struct
	mov_ecx, %0                                 # We wish to return NULL
	jmp %type_name_done                         # be done

:type_name_native
	# Deal only with native types
	mov_eax,ebx                                 # Put global_token->S in the right place
	mov_ebx,[DWORD] &global_types               # get all known types
	call %lookup_type                           # Find the type if possible
	mov_ecx,eax                                 # Set ret

	cmp_eax, !0                                 # IF NULL == ret
	jne %type_name_common                       # We need to abort hard

	# Aborting hard
	mov_eax, %2                                 # Using Standard error
	mov_[DWORD],eax &Output_file                # write to standard error
	mov_eax, &type_name_string_0                # Print header
	call %File_Print                            # Print it

	mov_eax,[DWORD] &global_token               # Using global token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %File_Print                            # Print it

	mov_eax, &type_name_string_1                # Print footer
	call %File_Print                            # Print it

#	call %line_error                            # Give details
	jmp %Exit_Failure                           # Abort

:type_name_common
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx]                               # global_token->next
	mov_[DWORD],ebx &global_token               # global_token = global_token->next

:type_name_iter
	mov_eax,[ebx+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # make it useful
	cmp_eax, !42                                # IF global_token->S[0] == '*'
	jne %type_name_done                         # recurse

	# Deal with char**
	mov_ecx,[ecx+BYTE] !12                      # ret = ret->indirect
	mov_ebx,[DWORD] &global_token               # Using global_token
	mov_ebx,[ebx]                               # global_token->next
	mov_[DWORD],ebx &global_token               # global_token = global_token->next
	jmp %type_name_iter                         # keep looping

:type_name_done
	mov_eax,ecx                                 # put ret in the right place
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:type_name_string_0  "Unknown type "
:type_name_string_1  "
"


# lookup_type function
# Receives char* s in EAX and struct type* start in EBX
# Returns struct type* in EAX
# Uses EBX for S and ECX for I
:lookup_type
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	mov_ecx,ebx                                 # I = Start
	mov_ebx,eax                                 # Put S in place
:lookup_type_iter
	cmp_ecx, !0                                 # Check if I == NULL
	je %lookup_type_done                        # return NULL

	mov_eax,[ecx+BYTE] !24                      # I->NAME
	call %match                                 # Check if matching
	cmp_eax, !0                                 # IF I->NAME == S
	je %lookup_type_done                        # return it

	mov_ecx,[ecx]                               # Otherwise I = I->NEXT
	jmp %lookup_type_iter                       # And keep looping

:lookup_type_done
	mov_eax,ecx                                 # return either I or NULL
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# create_struct function
# Receives nothing
# Returns nothing
# Uses global_token to malloc a struct's definition
# Uses ECX for int OFFSET, EDX for struct type* head, EBP for struct type* I,
# EDI for member_size (Which is passed) and ESI for LAST
# EAX and EBX are used for scratch
:create_struct
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_ebp                                    # Protect EBP
	push_edi                                    # Protect EDI
	push_esi                                    # Protect ESI
	mov_ecx, %0                                 # OFFSET = 0
	mov_edi, %0                                 # member_size = 0

	mov_eax, %28                                # sizeof(struct type)
	call %malloc                                # malloc(sizeof(struct type))
	mov_edx,eax                                 # Set HEAD

	mov_eax, %28                                # sizeof(struct type)
	call %malloc                                # malloc(sizeof(struct type))
	mov_ebp,eax                                 # Set I

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_[edx+BYTE],eax !24                      # HEAD->NAME = global_token->S
	mov_[ebp+BYTE],eax !24                      # I->NAME = global_token->S

	mov_[edx+BYTE],ebp !12                      # HEAD->INDIRECT = I
	mov_[ebp+BYTE],edx !12                      # I->INDIRECT = HEAD

	mov_eax,[DWORD] &global_types               # Using global_types
	mov_[edx],eax                               # HEAD->NEXT = global_types
	mov_[DWORD],edx &global_types               # global_types = HEAD

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, %4                                 # Using register size
	mov_[ebp+BYTE],eax !4                       # I->SIZE = register size

	mov_eax, &create_struct_string_0            # Using "ERROR in create_struct\n Missing {\n"
	mov_ebx, &open_curly_brace                  # Using "{"
	call %require_match                         # Make sure we have it

	mov_esi, %0                                 # LAST = NULL

:create_struct_iter
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # Make it useful
	cmp_eax, !125                               # IF global_token->S[0] == "}"
	je %create_struct_done                      # be done

	# Looks like we are adding members
	# Lets see if it is a union
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_ebx, &union                             # Using "union"
	call %match                                 # IF match(global_token->s, "union")
	cmp_eax, !0                                 # Deal with union
	jne %create_struct_single                   # Otherwise deal with singles

	# Deal with union
	mov_eax,esi                                 # Put last in right place
	mov_ebx,ecx                                 # put offset in right place
	call %build_union                           # ASSEMBLE
	mov_esi,eax                                 # last = build_union(last, offset)
	add_ecx,edi                                 # offset = offset + member_size

	mov_eax, &create_struct_string_1            # Using "ERROR in create_struct\n Missing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it
	jmp %create_struct_iter                     # keep going

:create_struct_single
	# deal with singles
	mov_eax,esi                                 # Put last in right place
	mov_ebx,ecx                                 # put offset in right place
	call %build_member                          # ASSEMBLE
	mov_esi,eax                                 # last = build_union(last, offset)
	add_ecx,edi                                 # offset = offset + member_size

	mov_eax, &create_struct_string_1            # Using "ERROR in create_struct\n Missing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it
	jmp %create_struct_iter                     # keep going

:create_struct_done
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &create_struct_string_1            # Using "ERROR in create_struct\n Missing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it

	mov_[edx+BYTE],ecx !4                       # HEAD->SIZE = OFFSET
	mov_[edx+BYTE],esi !16                      # HEAD->MEMBERS = LAST
	mov_[ebp+BYTE],esi !16                      # I->MEMBERS = LAST

	pop_esi                                     # Restore ESI
	pop_edi                                     # Restore EDI
	pop_ebp                                     # Restore EBP
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:create_struct_string_0  "ERROR in create_struct
 Missing {
"
:create_struct_string_1  "ERROR in create_struct
 Missing ;
"


# lookup_member function
# Receives struct type* parent in EAX and char* name in EBX
# Returns struct type* I in EAX
# Uses char* NAME in EBX, ECX for struct type* I and EDX to hold parent for errors
# Aborts hard if not found
:lookup_member
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_edx,eax                                 # Protect Parent
	mov_ecx,[eax+BYTE] !16                      # struct type* I = parent->MEMBERS
:lookup_member_iter
	cmp_ecx, !0                                 # IF I == NULL
	je %lookup_member_fail                      # Abort HARD

	mov_eax,[ecx+BYTE] !24                      # Using I->NAME
	call %match                                 # IF I->NAME == NAME
	cmp_eax, !0                                 # Then we have found the member
	mov_eax,ecx                                 # Prepare for return
	mov_ecx,[ecx+BYTE] !16                      # Prepare for loop I = I->MEMBERS
	jne %lookup_member_iter                     # Looks like we are looping

	# I is already in EAX
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:lookup_member_fail
	mov_eax, %2                                 # Using Standard error
	mov_[DWORD],eax &Output_file                # write to standard error
	mov_eax, &lookup_member_string_0            # Using "ERROR in lookup_member "
	call %File_Print                            # print it

	mov_eax,[edx+BYTE] !24                      # PARENT->NAME
	call %File_Print                            # print it

	mov_eax, &arrow_string                      # Using "->"
	call %File_Print                            # print it

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %File_Print                            # print it

	mov_eax, &lookup_member_string_1            # Using " does not exist\n"
	call %File_Print                            # print it

#	call %line_error                            # Write useful debug info

	mov_eax, &lookup_member_string_2            # Using "\n"
	call %File_Print                            # print it
	jmp %Exit_Failure                           # Abort Hard

:lookup_member_string_0  "ERROR in lookup_member "
:lookup_member_string_1  " does not exist
"
:lookup_member_string_2  "
"


# build_member function
# Receives struct type* last in EAX, int offset in EBX and global member_size in EDI
# Updates member_size in EDI and returns struct type* I in EAX
# Uses ECX for struct type* member_type and EDX for struct type* I
:build_member
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_edx,eax                                 # Put last out of the way
	mov_eax, %28                                # Allocate type
	call %malloc                                # Get I
	mov_[eax+BYTE],edx !16                      # I->MEMBERS = LAST
	mov_[eax+BYTE],ebx !8                       # I->OFFSET = OFFSET
	mov_edx,eax                                 # Put I in place

	call %type_name                             # Get member_type
	mov_ecx,eax                                 # Put in place
	mov_[edx+BYTE],ecx !20                      # I->TYPE = MEMBER_TYPE
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_ebx,[eax+BYTE] !8                       # global_token->S
	mov_[edx+BYTE],ebx !24                      # I->NAME = global_token->S
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	# Check if we have an array
	mov_ebx,[eax+BYTE] !8                       # global_token->S
	mov_eax, &open_bracket                      # Using "["
	call %match                                 # IF global_token->S == "["
	cmp_eax, !0                                 # Then we have to deal with arrays in our structs
	je %build_member_array                      # So deal with that pain

	# Deal with non-array case
	mov_eax,[ecx+BYTE] !4                       # member_type->SIZE
	mov_[edx+BYTE],eax !4                       # I->SIZE = member_type->SIZE
	jmp %build_member_done                      # Be done

:build_member_array
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax,[eax+BYTE] !8                       # global_token->S
	call %numerate_string                       # convert number
	mov_ebx,[ecx+BYTE] !20                      # member_type->TYPE
	mov_ebx,[ebx+BYTE] !4                       # member_type->TYPE->SIZE
	imul_eax,ebx                                # member_type->type->size * numerate_string(global_token->s)
	mov_[edx+BYTE],eax !4                       # I->SIZE = member_type->type->size * numerate_string(global_token->s)

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &build_member_string_0             # Using "Struct only supports [num] form\n"
	mov_ebx, &close_bracket                     # Using "]"
	call %require_match                         # Make sure we have it

:build_member_done
	mov_edi,[edx+BYTE] !4                       # MEMBER_SIZE = I->SIZE
	mov_[edx+BYTE],ecx !20                      # I->TYPE = MEMBER_TYPE
	mov_eax,edx                                 # Return I

	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:build_member_string_0  "Struct only supports [num] form
"


# build_union function
# Receives struct type* last in EAX, int offset in EBX and global member_size in EDI
# Updates member_size in EDI and returns struct type* LAST in EAX
# Uses ECX for struct type* last, EDX for int offset, ESI for int size and EDI for int member_size
:build_union
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_esi                                    # Protect ESI
	mov_ecx,eax                                 # Put LAST in right spot
	mov_edx,ebx                                 # Put OFFSET in right spot
	mov_esi, %0                                 # SIZE = 0

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax, &build_union_string_0              # Using "ERROR in build_union\nMissing {\n"
	mov_ebx, &open_curly_brace                  # Using "{"
	call %require_match                         # Make sure we have it

:build_union_iter
	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax+BYTE] !8                       # global_token->S
	mov_al,[eax]                                # global_token->S[0]
	movzx_eax,al                                # make it useful
	cmp_eax, !125                               # IF global_token->S[0] == "}"
	je %build_union_done                        # Be done

	# Collect union member
	mov_eax,ecx                                 # Passing LAST
	mov_ebx,edx                                 # Passing offset
	call %build_member                          # build_member(last, offset)
	mov_ecx,eax                                 # last = build_member(last, offset)

	cmp_esi,edi                                 # IF member_size > size
	jg %build_union_size                        # Then update size

	# deal with member_size > size
	mov_esi,edi                                 # SIZE = MEMBER_SIZE

:build_union_size
	mov_eax, &build_union_string_1              # Using "ERROR in build_union\nMissing ;\n"
	mov_ebx, &semicolon                         # Using ";"
	call %require_match                         # Make sure we have it
	jmp %build_union_iter                       # Keep going

:build_union_done
	mov_edi,esi                                 # MEMBER_SIZE = SIZE

	mov_eax,[DWORD] &global_token               # Using global_token
	mov_eax,[eax]                               # global_token->NEXT
	mov_[DWORD],eax &global_token               # global_token = global_token->NEXT

	mov_eax,ecx                                 # Return last

	pop_esi                                     # Restore ESI
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:build_union_string_0  "ERROR in build_union
Missing {
"
:build_union_string_1  "ERROR in build_union
Missing ;
"


# sym_declare function
# Receives char *s in EAX, struct type* t in EBX, and struct token_list* list in ECX
# Returns struct token_list* in EAX
# Uses EAX for A
:sym_declare
	push_edx                                    # Protect EDX
	mov_edx,eax                                 # Get char *S safely out of the way
	mov_eax, %20                                # Using sizeof(struct token_list)
	call %malloc                                # Get pointer to A
	mov_[eax],ecx                               # A->NEXT = LIST
	mov_[eax+BYTE],edx !8                       # A->S = S
	mov_[eax+BYTE],ebx !12                      # A->TYPE = T
	pop_edx                                     # Restore EDX
	ret


# match function
# Receives CHAR* in EAX and CHAR* in EBX
# Returns 0 (TRUE) or 1 (FALSE) in EAX
:match
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	mov_ecx,eax                                 # S1 in place
	mov_edx,ebx                                 # S2 in place
:match_Loop
	mov_al,[ecx]                                # S1[0]
	movzx_eax,al                                # Make it useful
	mov_bl,[edx]                                # S2[0]
	movzx_ebx,bl                                # Make it useful
	cmp_eax,ebx                                 # See if they match
	jne %match_False                            # If not

	add_ecx, !1                                 # S1 = S1 + 1
	add_edx, !1                                 # S2 = S2 + 1
	cmp_eax, !0                                 # If reached end of string
	je %match_Done                              # Perfect match
	jmp %match_Loop                             # Otherwise keep looping

:match_False
	mov_eax, %1                                 # Return false
:match_Done
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# numerate_number function
# Receives an INT A in EAX
# Returns char* result in EAX
# Allocates 16 bytes of memory
# Behaves badly when given a negative number too large
# Uses EAX for temp, EBX for DIVISOR, EDX for mod/0, ESI for result[i] and EBP for A
:numerate_number
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_esi                                    # Protect ESI
	push_ebp                                    # Protect EBP
	mov_ebp,eax                                 # Protect A

	mov_eax, %16                                # 16 bytes
	call %malloc                                # Get our pointer
	push_eax                                    # Protect our pointer
	mov_esi,eax                                 # put pointer in right place
	mov_ebx, %0x3B9ACA00                        # Set divisor to largest positive number that fits in 32bits

	cmp_ebp, !0                                 # Deal with 0 case
	je %numerate_number_ZERO                    # If it is
	jg %numerate_number_positive                # If it is positive

	# Deal with negative case
	mov_eax, %45                                # Using "-"
	mov_[esi],al                                # Write it
	add_esi, !1                                 # increment
	imul_ebp, !-1                               # A = A * -1

:numerate_number_positive
	mov_edx, %0                                 # Set top to 0
	mov_eax,ebp                                 # Using A as bottom
	idiv_ebx                                    # edx:eax % ebx -> edx + edx:eax / ebx -> eax [Even if we don't want it]
	cmp_eax, !0                                 # IF 0 == (a / divisor)
	jne %numerate_number_iter                   # Clean up those leading Zeros

	mov_edx, %0                                 # Set top to 0
	mov_eax,ebx                                 # Using Divisor for bottom
	mov_ebx, %10                                # Make this shit work because idiv 10 doesn't work
	idiv_ebx                                    # edx:eax % 10 -> edx + edx:eax / 10 -> eax [Even if we don't want it]
	mov_ebx,eax                                 # Update divisor
	jmp %numerate_number_positive               # Keep collecting

:numerate_number_iter
	cmp_ebx, !0                                 # IF DIVISOR < 0
	jle %numerate_number_done                   # Be done

	mov_edx, %0                                 # Set top to 0
	mov_eax,ebp                                 # Using A as bottom
	idiv_ebx                                    # edx:eax % ebx -> edx + edx:eax / ebx -> eax [Even if we don't want it]
	add_eax, !48                                # ((a / divisor) + 48)
	mov_[esi],al                                # Write it
	mov_ebp,edx                                 # a = a % divisor

	mov_edx, %0                                 # Set top to 0
	mov_eax,ebx                                 # Using Divisor for bottom
	mov_ebx, %10                                # Make this shit work because idiv 10 doesn't work
	idiv_ebx                                    # edx:eax % 10 -> edx + edx:eax / 10 -> eax [Even if we don't want it]
	mov_ebx,eax                                 # Update divisor

	add_esi, !1                                 # increment
	jmp %numerate_number_iter                   # Keep going

:numerate_number_done
	pop_eax                                     # Restore our result
	pop_ebp                                     # Restore EBP
	pop_esi                                     # Restore ESI
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret

:numerate_number_ZERO
	mov_eax, %48                                # Using '0'
	mov_[esi],al                                # Write it
	add_esi, !1                                 # increment
	jmp %numerate_number_done                   # Be done


# numerate_string function
# Receives CHAR* in EAX
# Returns value of CHAR* in EAX
# Uses EAX for VALUE, EBX for S, ECX for CH and ESI for NEGATIVE?
:numerate_string
	push_ebx                                    # Protect EBX
	push_ecx                                    # Protect ECX
	push_edx                                    # Protect EDX
	push_esi                                    # Protect ESI
	mov_ebx,eax                                 # put S in correct place
	mov_eax, %0                                 # Initialize to Zero
:numerate_string_loop
	mov_cl,[ebx+BYTE] !1                        # S[1]
	movzx_ecx,cl                                # make it useful
	cmp_ecx, !120                               # IF 'x' == S[1]
	je %numerate_hex                            # Deal with hex input

	# Assume decimal input
	mov_esi, %0                                 # Assume no negation
	mov_cl,[ebx]                                # S[0]
	movzx_ecx,cl                                # make it useful
	cmp_ecx, !45                                # IF '-' == S[0]
	jne %numerate_decimal                       # Skip negation

	mov_esi, %1                                 # Set FLAG
	add_ebx, !1                                 # S = S + 1

:numerate_decimal
	mov_cl,[ebx]                                # S[0]
	movzx_ecx,cl                                # make it useful
	cmp_ecx, !0                                 # IF NULL == S[0]
	je %numerate_decimal_done                   # We are done

	imul_eax, !10                               # VALUE = VALUE * 10
	sub_ecx, !48                                # CH = CH - '0'
	cmp_ecx, !9                                 # Check for illegal
	jg %numerate_string_fail                    # If CH > '9'
	cmp_ecx, !0                                 # Check for illegal
	jl %numerate_string_fail                    # IF CH < 0
	add_eax,ecx                                 # VALUE = VALUE + CH
	add_ebx, !1                                 # S = S + 1
	jmp %numerate_decimal                       # Keep looping

:numerate_decimal_done
	cmp_esi, !1                                 # Check if need to negate
	jne %numerate_string_done                   # Nope

	imul_eax, !-1                               # VALUE = VALUE * -1
	jmp %numerate_string_done                   # Done

:numerate_hex
	add_ebx, !2                                 # S = S + 2
:numerate_hex_loop
	mov_cl,[ebx]                                # S[0]
	movzx_ecx,cl                                # make it useful
	cmp_ecx, !0                                 # IF NULL == S[0]
	je %numerate_string_done                    # We are done

	sal_eax, !4                                 # VALUE = VALUE << 4
	sub_ecx, !48                                # CH = CH - '0'
	cmp_ecx, !10                                # IF 10 >= CH
	jl %numerate_hex_digit                      # NO
	sub_ecx, !7                                 # Push A-F into range
:numerate_hex_digit
	cmp_ecx, !15                                # Check for illegal
	jg %numerate_string_fail                    # If CH > 'F'
	cmp_ecx, !0                                 # Check for illegal
	jl %numerate_string_fail                    # IF CH < 0
	add_eax,ecx                                 # VALUE = VALUE + CH
	add_ebx, !1                                 # S = S + 1
	jmp %numerate_hex_loop                      # Keep looping

:numerate_string_fail
	mov_eax, %0                                 # return ZERO

:numerate_string_done
	pop_esi                                     # Restore ESI
	pop_edx                                     # Restore EDX
	pop_ecx                                     # Restore ECX
	pop_ebx                                     # Restore EBX
	ret


# Exit_Failure function
# Receives nothing
# And aborts hard
# Does NOT return
:Exit_Failure
	mov_ebx, %1                                 # All is wrong
	mov_eax, %1                                 # put the exit syscall number in eax
	int !0x80                                   # Call it a bad day

# Keywords
:union  "union"
:struct  "struct"
:enum  "enum"
:main_string  "main"
:argc_string  "argc"
:argv_string  "argv"
:if_string  "if"
:else_string  "else"
:do_string  "do"
:while_string  "while"
:for_string  "for"
:asm_string  "asm"
:goto_string  "goto"
:return_string  "return"
:break_string  "break"
:continue_string  "continue"
:sizeof_string  "sizeof"
:plus_string  "+"
:minus_string  "-"
:multiply_string  "*"
:divide_string  "/"
:modulus_string  "%"
:left_shift_string  "<<"
:right_shift_string  ">>"
:less_than_string  "<"
:less_than_equal_string  "<="
:greater_than_equal_string  ">="
:greater_than_string  ">"
:equal_to_string  "=="
:not_equal_string  "!="
:bitwise_and  "&"
:logical_and  "&&"
:bitwise_or  "|"
:logical_or  "||"
:bitwise_xor  "^"
:arrow_string  "->"


# Frequently Used strings
# Generally used by require_match
:open_curly_brace  "{"
:close_curly_brace  "}"
:open_paren  "("
:close_paren  ")"
:open_bracket  "["
:close_bracket  "]"
:comma  ","
:semicolon  ";"
:equal  "="
:percent  "%"
:newline  "\n"
:underline  "_"


:prim_types
:type_void
	&type_int                                   # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_void                                  # INDIRECT
	%0                                          # MEMBERS
	&type_void                                  # TYPE
	&type_void_name                             # NAME
:type_void_name  "void"

:type_int
	&type_char                                  # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_int                                   # INDIRECT
	%0                                          # MEMBERS
	&type_int                                   # TYPE
	&type_int_name                              # NAME
:type_int_name  "int"

:type_char
	&type_file                                  # NEXT
	%1                                          # SIZE
	%0                                          # OFFSET
	&type_char_indirect                         # INDIRECT
	%0                                          # MEMBERS
	&type_char                                  # TYPE
	&type_char_name                             # NAME
:type_char_name  "char"

:type_char_indirect
	&type_file                                  # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_char_double_indirect                  # INDIRECT
	%0                                          # MEMBERS
	&type_char_indirect                         # TYPE
	&type_char_indirect_name                    # NAME
:type_char_indirect_name  "char*"

:type_char_double_indirect
	&type_file                                  # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_char_double_indirect                  # INDIRECT
	%0                                          # MEMBERS
	&type_char_indirect                         # TYPE
	&type_char_double_indirect_name             # NAME
:type_char_double_indirect_name  "char**"

:type_file
	&type_function                              # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_file                                  # INDIRECT
	%0                                          # MEMBERS
	&type_file                                  # TYPE
	&type_file_name                             # NAME
:type_file_name  "FILE"

:type_function
	&type_unsigned                              # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_function                              # INDIRECT
	%0                                          # MEMBERS
	&type_function                              # TYPE
	&type_function_name                         # NAME
:type_function_name  "FUNCTION"

:type_unsigned
	&type_long                                  # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_unsigned                              # INDIRECT
	%0                                          # MEMBERS
	&type_unsigned                              # TYPE
	&type_unsigned_name                         # NAME
:type_unsigned_name  "unsigned"

:type_long
	%0                                          # NEXT
	%4                                          # SIZE
	%0                                          # OFFSET
	&type_long                                  # INDIRECT
	%0                                          # MEMBERS
	&type_long                                  # TYPE
	&type_long_name                             # NAME
:type_long_name  "long"

# debug_list function
# Receives struct token_list* in EAX
# Prints contents of list and exits
# Does NOT return
:debug_list
	mov_ebp,eax                                 # Protect the list pointer
	mov_eax, %2                                 # Using Standard error
	mov_[DWORD],eax &Output_file                # write to standard error

:debug_list_iter
	# Header
	mov_eax, &debug_list_string0                # Using our first string
	call %File_Print                            # Print it
	mov_eax,ebp                                 # Use address of pointer
	call %numerate_number                       # Convert it into string
	call %File_Print                            # Print it

	# NEXT
	mov_eax, &debug_list_string1                # Using our second string
	call %File_Print                            # Print it
	mov_eax,[ebp+BYTE] !0                       # Use address of pointer
	call %numerate_number                       # Convert it into string
	call %File_Print                            # Print it

	# PREV
	mov_eax, &debug_list_string2                # Using our third string
	call %File_Print                            # Print it
	mov_eax,[ebp+BYTE] !4                       # Use address of pointer
	call %numerate_number                       # Convert it into string
	call %File_Print                            # Print it

	# S
	mov_eax, &debug_list_string3                # Using our fourth string
	call %File_Print                            # Print it
	mov_eax,[ebp+BYTE] !8                       # Use address of pointer
	call %numerate_number                       # Convert it into string
	call %File_Print                            # Print it

	# S Contents
	mov_eax, &debug_list_string4                # Using our fifth string
	call %File_Print                            # Print it
	mov_eax,[ebp+BYTE] !8                       # Use address of string
	cmp_eax, !0                                 # IF NULL Pointer
	jne %debug_list_null                        # otherwise display
	mov_eax, &debug_list_string_null            # Give meaningful message instead
:debug_list_null
	call %File_Print                            # Print it

	# TYPE
	mov_eax, &debug_list_string5                # Using our sixth string
	call %File_Print                            # Print it
	mov_eax,[ebp+BYTE] !12                      # Use address of pointer
	call %numerate_number                       # Convert it into string
	call %File_Print                            # Print it

	# ARGS/DEPTH
	mov_eax, &debug_list_string6                # Using our seventh string
	call %File_Print                            # Print it
	mov_eax,[ebp+BYTE] !16                      # Use address of pointer
	call %numerate_number                       # Convert it into string
	call %File_Print                            # Print it

	mov_eax, %10                                # Add "\n"
	call %fputc                                 # print it
	call %fputc                                 # print it

	mov_ebp,[ebp]                               # TOKEN = TOKEN->NEXT
	cmp_ebp, !0                                 # Check if NULL
	jne %debug_list_iter                        # iterate otherwise

	mov_ebx, %666                               # All is HELL
	mov_eax, %1                                 # put the exit syscall number in eax
	int !0x80                                   # Call it a bad day

:debug_list_string0  "Token_list node at address: "
:debug_list_string1  "
NEXT address: "
:debug_list_string2  "
PREV address: "
:debug_list_string3  "
S address: "
:debug_list_string4  "
The contents of S are: "
:debug_list_string5  "
TYPE address: "
:debug_list_string6  "
ARGUMENTS address: "
:debug_list_string_null  ">::<NULL>::<"


:Address_of
	NULL
:C
	NULL
:Input_file
	NULL
:MALLOC
	NULL
:Output_file
	NULL
:Token
	NULL
:break_frame
	NULL
:break_target_func
	NULL
:break_target_head
	NULL
:break_target_num
	NULL
:current_count
	NULL
:current_target
	NULL
:function
	NULL
:global_constant_list
	NULL
:global_function_list
	NULL
:global_symbol_list
	NULL
:global_token
	NULL
:global_types
	&prim_types
:globals_list
	NULL
:output_list
	NULL
:string_index
	NULL
:strings_list
	NULL

:ELF_end
